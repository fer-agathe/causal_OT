# Gaussian Example - Simulations {#sec-gaussian-ex-simul}


:::{.callout-note}

## Objectives

In this page, XXX



:::

```{r package-settings}
#| warning: false
#| message: false
library(tidyverse)
library(mnormt)
```

```{r}
#| warning: false
#| message: false
#| code-fold: true
#| code-summary: Codes for graphical parameters
library(extrafont, quietly = TRUE)
col_group <- c("#1b95e0","#7F170E", "#00A08A")
colGpe1 <- col_group[2]
colGpe0 <- col_group[1]
colGpet <- col_group[3]
loadfonts(device = "pdf", quiet = TRUE)
font_size <- 20
font_family <- "CMU Serif"

path <- "./figs/"
if (!dir.exists(path)) dir.create(path)

theme_paper <- function(...) {
  font_size <- 20
  theme(
    text = element_text(family = font_family, size = unit(font_size, "pt")),
    plot.background = element_rect(fill = "transparent"),
    legend.key = element_blank(),
    panel.spacing = unit(1, "lines"),
    panel.background = element_rect(fill = NA, colour = "black"),
    panel.grid.major = element_line(colour = "grey80"),
    plot.title = element_text(hjust = 0, size = rel(1.3), face = "bold"),
    plot.title.position = "plot",
    strip.background = element_rect(fill = NA, colour = NA)
  )
}
```



```{r}
#| echo: false
#| eval: true
#| message: false
#| warning: false
#| file: _myfunctions.R
```

$$
\definecolor{wongBlack}{RGB}{0,0,0}
\definecolor{wongGold}{RGB}{230, 159, 0}
\definecolor{wongLightBlue}{RGB}{86, 180, 233}
\definecolor{wongGreen}{RGB}{0, 158, 115}
\definecolor{wongYellow}{RGB}{240, 228, 66}
\definecolor{wongBlue}{RGB}{0, 114, 178}
\definecolor{wongOrange}{RGB}{213, 94, 0}
\definecolor{wongPurple}{RGB}{204, 121, 167}
\definecolor{colA}{RGB}{255, 221, 85}
\definecolor{colB}{RGB}{148, 78, 223}
\definecolor{colC}{RGB}{63, 179, 178}
\definecolor{colGpe1}{RGB}{127, 23, 14}
\definecolor{colGpe0}{RGB}{27, 149, 224}
$$

# Functions

Let us redefine the function shown in [Chapter -@sec-motivation-gaussian] that will be used to perform the simulations here.

```{r}
#| code-fold: true
#| code-summary: Functions used to generate the data (`gen_data()`{.R}), create counterfactuals with optimal transport (`compute_ot_map()`{.R}, `apply_ot_transport()`{.R}) and sequential transport (`sequential_transport_12()`{.R}, `sequential_transport_21()`{.R}), compute the total causal effect based on (`causal_effects_cf()`{.R})
## Data----

#' @param n Number of units.
#' @param mu0 Mean of the two covariates in group 0.
#' @param mu1 Mean of the two covariates in group 1.
#' @param r0 Covariance of the two covariates in group 0.
#' @param r1 Covariance of the two covariates in group 1.
#' @parma a Shift parameter for the mean in both groups
#'  (default to 1: no shift). Larger values decreases overlapping.
gen_data <- function(n = 500,
                     mu0 = -1,
                     mu1 = +1,
                     r0 = +.7,
                     r1 = -.5,
                     a = 1,
                     seed = NULL) {
  
  if (!is.null(seed)) set.seed(seed)
  
  a0 <-  3
  a1 <-  2
  a2 <-  -1.5
  p1 <- .5
  Mu0 <- rep(mu0, 2)
  Mu1 <- rep(mu1, 2)
  Sig0 <- matrix(c(1, r0, r0, 1), 2, 2)
  Sig1 <- matrix(c(1, r1, r1, 1), 2, 2)
  # Draw covariates
  X0 <- rmnorm(n, mean = a * Mu0, varcov = Sig0)
  X1 <- rmnorm(n, mean = a * Mu1, varcov = Sig1)
  # Random noise
  E <- rnorm(n)
  # Binary treatment
  A <- sample(0:1, size = n, replace = TRUE, prob = c(1 - p1, p1))
  X <- X0
  X[A==1, ] = X1[A==1, ]
  df <- tibble(
    X1 = X[, 1],
    X2 = X[, 2],
    A = A,
    Y0 = a1 * X1 + a2 * X2 + E,
    Y1 = a1 * X1 + a2 * X2 + a0 + E,
    Y = A * Y1 + (1-A) * Y0
  )
  
  df
}

## Optimal Transport----


# The optimal transport map $T(x)$ from $\mathcal{N}(\mu_0, \Sigma_0)$ to
# $\mathcal{N}(\mu_1, \Sigma_1)$ is:
# $$T(x) = \mu_1 + A(x - \mu_0)$$
# where:
# $$
#   A = \Sigma_1^{1/2} 
#         \left( \Sigma_1^{1/2} \Sigma_0 \Sigma_1^{1/2} \right)^{-1/2}
#        \Sigma_1^{1/2}
# $$

#' Optimal transport mapping between two Gaussian distributions 
#'  (from \eqn{\mathcal{N}(\mu_0, \Sigma_0)} to 
#'  \eqn{\mathcal{N}(\mu_1, \Sigma_1)})
#'  
#' @param mu0 Means of the bivariate Gaussian in group 0.
#' @param sigma0 Variance-covariance matrix of the bivariate Gaussian in group 0.
#' @param mu1  Means of the bivariate Gaussian in group0.
#' @param sigma1 Variance-covariance matrix of the bivariate Gaussian in group 1.
compute_ot_map <- function(mu0, sigma0, mu1, sigma1) {
  
  sqrt_sigma0 <- sqrtm(sigma0)
  sqrt_sigma0_inv <- solve(sqrt_sigma0)
  inner <- sqrt_sigma0 %*% sigma1 %*% sqrt_sigma0
  sqrt_inner <- sqrtm(inner)

  A <- sqrt_sigma0_inv %*% sqrt_inner %*% sqrt_sigma0_inv
  
  list(A = A, shift = mu1 - A %*% mu0)
}

#' Function to apply the transport map to simulated data
#' 
#' @param X Observations to transport.
#' @param mapping Optimal transport mapping (from `compute_ot_map()`)?
apply_ot_transport <- function(X, mapping) {
  A <- mapping$A
  shift <- mapping$shift
  t(apply(X, 1, function(x) as.vector(shift + A %*% x)))
}

## Sequential Optimal Transport----

#' Sequential transport from N(M_source, S_source) to N(M_target, S_target),
#' along X1, then X2 | X1
#'
#' @param X n x 2 matrix of source observations.
#' @param M_source Mean vector of the source distribution (length 2).
#' @param S_source Covariance matrix of the source distribution (2x2).
#' @param M_target Mean vector of the target distribution.
#' @param S_target Covariance matrix of the target distribution.
sequential_transport_12 <- function(X, 
                                    M_source, 
                                    S_source, 
                                    M_target, 
                                    S_target) {
  
  # marginal univariate transport along the first coordinate (X_1)
  T1x <- qnorm(
    pnorm(X[, 1], mean = M_source[1], sd = sqrt(S_source[1, 1])),
    mean = M_target[1], sd = sqrt(S_target[1, 1])
  )
  
  # conditional parameters for X_2 | X_1
  m_source <- M_source[2] + S_source[1, 2] / S_source[1, 1] * (X[, 1] - M_source[1])
  s_source <- S_source[2, 2] - S_source[1, 2]^2 / S_source[1, 1]
  
  m_target <- M_target[2] + S_target[1, 2] / S_target[1, 1] * (T1x - M_target[1])
  s_target <- S_target[2, 2] - S_target[1, 2]^2 / S_target[1, 1]
  
  # conditional transport for the second coordinate
  T2x <- qnorm(
    pnorm(X[, 2], mean = m_source, sd = sqrt(s_source)),
    mean = m_target, sd = sqrt(s_target)
  )
  
  cbind(T1x, T2x)
}

#' Sequential transport from N(M_source, S_source) to N(M_target, S_target),
#' along X2, then X1 | X2
#'
#' @param X n x 2 matrix of source observations.
#' @param M_source Mean vector of the source distribution (length 2).
#' @param S_source Covariance matrix of the source distribution (2x2).
#' @param M_target Mean vector of the target distribution.
#' @param S_target Covariance matrix of the target distribution.
sequential_transport_21 <- function(X, M_source, S_source, M_target, S_target) {
  
  # marginal univariate transport along X_2
  T2x <- qnorm(
    pnorm(X[, 2], mean = M_source[2], sd = sqrt(S_source[2, 2])),
    mean = M_target[2], sd = sqrt(S_target[2, 2])
  )
  
  # conditional parameters for X_1 | X_2
  m_source <- M_source[1] + S_source[1, 2] / S_source[2, 2] * (X[, 2] - M_source[2])
  s_source <- S_source[1, 1] - S_source[1, 2]^2 / S_source[2, 2]
  
  m_target <- M_target[1] + S_target[1, 2] / S_target[2, 2] * (T2x - M_target[2])
  s_target <- S_target[1, 1] - S_target[1, 2]^2 / S_target[2, 2]
  
  # conditional transport for X1 | X_2
  T1x <- qnorm(
    pnorm(X[, 1], mean = m_source, sd = sqrt(s_source)),
    mean = m_target, sd = sqrt(s_target)
  )
  
  cbind(T1x, T2x)
}

## Causal Effect----

#' Average treatment on the treated using counterfactuals.
#' 
#' @param data_untreated Dataset with the untreated units only.
#' @param data_treated Dataset with the treated units only.
#' @param data_cf Counterfactuals (untreated had they been treated).
#' @param Y_name Name of the column with the outcome variable.
#' @param A_name Name of the column with the treatment variable.
#' @param A_untreated Value of the treatment for the untreated units.
causal_effects_cf <- function(data_untreated,
                              data_treated,
                              data_cf,
                              Y_name,
                              A_name,
                              A_untreated) {
  
  n_untreated <- nrow(data_untreated)
  n_treated <- nrow(data_treated)
  
  # Outcome model for untreated
  mu_untreated_model <- randomForest(
    x = data_untreated |> dplyr::select(-!!Y_name, -!!A_name),
    y = pull(data_untreated, !!Y_name)
  )
  
  # Outcome model for treated
  mu_treated_model <- randomForest(
    x = data_treated |> dplyr::select(-!!Y_name, -!!A_name),
    y = pull(data_treated, !!Y_name)
  )
  
  # Observed outcome for untreated
  Y_untreated_obs <- data_untreated |> pull(!!Y_name)
  
  # Natural Indirect Effect
  delta_0_i <- predict(mu_untreated_model, newdata = data_cf) - Y_untreated_obs
  delta_0 <- mean(delta_0_i)
  # Natural Direct Effect
  zeta_1_i <- predict(mu_treated_model, newdata = data_cf) - 
    predict(mu_untreated_model, newdata = data_cf)
  zeta_1 <- mean(zeta_1_i)
  # Total Causal Effect for treated
  tot_effect <- delta_0 + zeta_1
  
  list(
    delta_0_i = delta_0_i,
    delta_0 = delta_0,
    zeta_1_i = zeta_1_i,
    zeta_1 = zeta_1,
    tot_effect = tot_effect
  )
}
```

We define the function `sim_f()`{.R} to run a single replication of the Monte-Carlo simulations. This functions proceeds in the following steps:

1. Generate data depending on the provided parameters for the DGP,
2. Build Counterfactuals (with optimal transport and with sequential optimal transport) of individuals from the untreated group ($A=0$),
3. Compute the total causal effect.

```{r sim_f}
sim_f <- function(n = 500,
                  mu0, 
                  mu1, 
                  r0, 
                  r1, 
                  a, 
                  seed = NULL) {
  
  if (!is.null(seed)) set.seed(seed)
  
  # 1. Generate data
  df <- gen_data(
    n = 500, 
    mu0 = mu0, mu1 = mu1, 
    r0 = r0, r1 = r1, a = a, 
    seed = seed
  )
  
  # 2. Building Counterfactuals
  
  ## With Optimal Transport
  # Transporting map for source: group 1, target: group 0 (careful here)
  Sigma0 <- matrix(c(1, r0, r0, 1), 2, 2)
  Sigma1 <- matrix(c(1, r1, r1, 1), 2, 2)
  Mu0 <- rep(a * mu0, 2)
  Mu1 <- rep(a * mu1, 2)
  ot_map <- compute_ot_map(mu0 = Mu0, sigma0 = Sigma0, mu1 = Mu1, sigma1 = Sigma1)
  # Apply transport map to treated units (A = 1)
  X0 <- as.matrix(df[df$A == 0, c("X1", "X2")])
  X0_t <- apply_ot_transport(X = X0, mapping = ot_map)
  colnames(X0_t) <- c(c("X1", "X2"))
  
  ## With Sequential Transport
  # Transport from group 0 to group 1: X1 then X2 | X1
  X0_st_12 <- sequential_transport_12(
    X = X0, M_source = Mu0, S_source = Sigma0, M_target = Mu1, S_target = Sigma1
  )
  # Transport from group 0 to group 1: X2 then X1 | X2
  X0_st_21 <- sequential_transport_21(
    X = X0, M_source = Mu0, S_source = Sigma0, M_target = Mu1, S_target = Sigma1
  )
  
  # 3. Measuring Total Causal Effect
  tb <- df[, c("Y", "A", "X1", "X2")]
  A_name <- "A"
  A_untreated <- 0
  Y_name <- "Y"
  
  # Causal Mediation Analysis
  med_mod <- mediation::multimed(
    outcome = "Y", 
    med.main = "X1", 
    med.alt = "X2", 
    treat = "A", 
    data = tb
  )
  delta_0_med <- mean((med_mod$d0.lb + med_mod$d0.ub) / 2)
  zeta_1_med <- mean((med_mod$z1.lb + med_mod$z1.ub) / 2)
  tot_effect_med <- delta_0_med + zeta_1_med
  
  # With OT counterfactuals
  tb_untreated <- tb |> filter(!!sym(A_name) == !!A_untreated)
  tb_treated <- tb |> filter(!!sym(A_name) != !!A_untreated)
  
  causal_effects_ot <- causal_effects_cf(
    data_untreated = tb_untreated, 
    data_treated = tb_treated,
    data_cf = as_tibble(X0_t), 
    Y_name = Y_name, A_name = A_name, A_untreated = A_untreated
  )
  
  # With Sequential Transport counterfactuals
  causal_effect_sot_12 <- causal_effects_cf(
    data_untreated = tb_untreated, 
    data_treated = tb_treated,
    data_cf = as_tibble(X0_st_12) |> magrittr::set_colnames(c("X1", "X2")),
    Y_name = Y_name, A_name = A_name, A_untreated = A_untreated
  )
  
  causal_effect_sot_21 <- causal_effects_cf(
    data_untreated = tb_untreated, 
    data_treated = tb_treated,
    data_cf = as_tibble(X0_st_21) |> magrittr::set_colnames(c("X1", "X2")),
    Y_name = Y_name, A_name = A_name, A_untreated = A_untreated
  )
  
  tibble(
    # Mediation
    delta_0_med = delta_0_med,
    zeta_1_med = zeta_1_med,
    tot_effect_med = tot_effect_med,
    # OT
    delta_0_ot = causal_effects_ot$delta_0,
    zeta_1_ot = causal_effects_ot$zeta_1,
    tot_effect_ot = causal_effects_ot$tot_effect,
    # SOT 12
    delta_0_sot_12 = causal_effect_sot_12$delta_0,
    zeta_1_sot_12 = causal_effect_sot_12$zeta_1,
    tot_effect_sot_12 = causal_effect_sot_12$tot_effect,
    # SOT 21
    delta_0_sot_21 = causal_effect_sot_21$delta_0,
    zeta_1_sot_21 = causal_effect_sot_21$zeta_1,
    tot_effect_sot_21 = causal_effect_sot_21$tot_effect,
    n = n,
    seed = seed,
    mu0 = mu0,
    mu1 = mu1,
    r0 = r0,
    r1 = r1,
    a = a
  )
}
```

## Monte-Carlo Simulations

We make the distance between the means of the Gaussian distributions of the two groups increase. With $\boldsymbol{\mu}_0 = \begin{pmatrix}-1\\-1\end{pmatrix}$ and $\boldsymbol{\mu}_1 = \begin{pmatrix}1\\1\end{pmatrix}$, the distance is equal to $1$. We apply a scalar coefficient $a\geq0$ to the means to increase that distance: $a\boldsymbol{\mu}_0$ and $a\boldsymbol{\mu}_1$. We make $a$ vary from 0 to 1 by steps of .1. When $a=0$, the distance is equal to $0$, when $a=2$, the distance is equal to $2$.

We define a grid with the different simulations.
```{r}
grid_params <- expand_grid(
  mu0 = -1,
  mu1 = +1,
  r0 = +.7,
  r1 = -.5,
  a = seq(0, 2, by = .1),
  seed = seq_len(20) # NEEDS TO BE LARGER AFTER
)
```

The simulations can be run in parallel, as follows.

```{r mc-simul, eval=FALSE}
# This chunk takes about XX minutes to run.
# We do not evaluate when compiling the document.
# Instead, we load previously obtained results.
library(pbapply)
library(parallel)
ncl <- detectCores()-1
(cl <- makeCluster(ncl))

clusterEvalQ(cl, {
  library(tidyverse)
  library(mnormt)
  library(expm)
  library(randomForest)
}) |>
  invisible()

clusterExport(
  cl = cl, c(
    "gen_data", "compute_ot_map", "apply_ot_transport",
    "sequential_transport_12", "sequential_transport_21",
    "causal_effects_cf", "sim_f", "grid_params"
  )
)

res_sim <- pbapply::pblapply(1:nrow(grid_params), function(i) {
  
  grid_params_current <- grid_params[i, ]
  
  mu0 <- grid_params_current$mu0
  mu1 <- grid_params_current$mu1
  r0 <- grid_params_current$r0
  r1 <- grid_params_current$r1
  a <- grid_params_current$a
  seed <- grid_params_current$seed
  
  sim_f(n = 500, mu0 = mu0, mu1 = mu1, r0 = r0, r1 = r1, a = a, seed = seed)
}, cl = cl)

stopCluster(cl)
res_sim <- list_rbind(res_sim)

save(res_sim, file = "../output/res_sim-gaussian-mc.rda")
```

We load previously obtained results:
```{r load-results-simul}
load("../output/res_sim-gaussian-mc.rda")
```

:::{.panel-tabset}

### Total Causal Effect

```{r}
#| fig-width: 8
#| fig-height: 6
#| code-fold: true
#| code-summary: Codes to create the Figure.
data_plot <- res_sim |> 
  dplyr::select(
    n, seed, a,
    tot_effect_med, tot_effect_ot, tot_effect_sot_12, tot_effect_sot_21
  ) |> 
  pivot_longer(
    cols = c(tot_effect_med, tot_effect_ot, tot_effect_sot_12, tot_effect_sot_21), 
    names_to = "type", values_to = "tau"
  ) |> 
  mutate(
    type = factor(
      type,
      levels = c(
        "tot_effect_med", "tot_effect_ot", 
        "tot_effect_sot_12", "tot_effect_sot_21"
      ),
      labels = c("CausalMed", "OT", "Seq OT (1)", "Seq OT (2)")
    ),
    dist_to_causal_effect = (3+a) - tau
  )
ggplot(
  data = data_plot,
  mapping = aes(x = factor(a), y = dist_to_causal_effect)
) +
  geom_violin(
    mapping = aes(fill = type)
  ) +
  geom_hline(yintercept = 0, colour = "darkred", linetype = "dashed") +
  theme_paper() +
  facet_wrap(~type, scales = "free_x", ncol = 2) +
  scale_fill_manual(
    NULL,
    values = c(
      "AIPW" = "#56B4E9", 
      "IPW" = "gray",
      "CausalMed" = "#E69F00",
      "OT" = "#CC79A7", 
      "Seq OT (1)" = "#009E73", 
      "Seq OT (2)" = "#D55E00"
    )
  ) +
  theme(legend.position = "bottom") +
  labs(
    x = latex2exp::TeX("Distance $\\alpha$"),
    y = "Distance to theoretical total causal effect",
  ) +
  scale_x_discrete(
    labels = ifelse(unique(data_plot$a) %% .5 == 0, unique(data_plot$a), "")
  )
```

### Natural Indirect Effect

```{r}
#| fig-width: 8
#| fig-height: 6
#| code-fold: true
#| code-summary: Codes to create the Figure.
data_plot <- res_sim |> 
  dplyr::select(
    n, seed, a, mu0, mu1,
    delta_0_med, delta_0_ot, delta_0_sot_12, delta_0_sot_21
  ) |> 
  pivot_longer(
    cols = c(delta_0_med, delta_0_ot, delta_0_sot_12, delta_0_sot_21), 
    names_to = "type", values_to = "val"
  ) |> 
  mutate(
    type = factor(
      type,
      levels = c(
        "delta_0_med", "delta_0_ot", "delta_0_sot_12", "delta_0_sot_21"
      ),
      labels = c("CausalMed", "OT", "Seq OT (1)", "Seq OT (2)")
    ),
    dist_to_theo_val = 2 * (a*mu1 - a*mu0) + (-1.5) * (a*mu1 - a*mu0) - val
  )
ggplot(
  data = data_plot,
  mapping = aes(x = factor(a), y = dist_to_theo_val)
) +
  geom_violin(
    mapping = aes(fill = type)
  ) +
  geom_hline(yintercept = 0, colour = "darkred", linetype = "dashed") +
  theme_paper() +
  facet_wrap(~type, scales = "free_x", ncol = 2) +
  scale_fill_manual(
    NULL,
    values = c(
      "AIPW" = "#56B4E9", 
      "IPW" = "gray",
      "CausalMed" = "#E69F00",
      "OT" = "#CC79A7", 
      "Seq OT (1)" = "#009E73", 
      "Seq OT (2)" = "#D55E00"
    )
  ) +
  theme(legend.position = "bottom") +
  labs(
    x = latex2exp::TeX("Distance $\\alpha$"),
    y = "Distance to theoretical natural indirect effect",
  ) +
  scale_x_discrete(
    labels = ifelse(unique(data_plot$a) %% .5 == 0, unique(data_plot$a), "")
  )
```

### Natural Direct Effect

```{r}
#| fig-width: 8
#| fig-height: 6
#| code-fold: true
#| code-summary: Codes to create the Figure.
data_plot <- res_sim |> 
  dplyr::select(
    n, seed, a, mu0, mu1,
    zeta_1_med, zeta_1_ot, zeta_1_sot_12, zeta_1_sot_21
  ) |> 
  pivot_longer(
    cols = c(zeta_1_med, zeta_1_ot, zeta_1_sot_12, zeta_1_sot_21), 
    names_to = "type", values_to = "val"
  ) |> 
  mutate(
    type = factor(
      type,
      levels = c(
        "zeta_1_med", "zeta_1_ot", "zeta_1_sot_12", "zeta_1_sot_21"
      ),
      labels = c("CausalMed", "OT", "Seq OT (1)", "Seq OT (2)")
    ),
    dist_to_theo_val = 3 - val
  )
ggplot(
  data = data_plot,
  mapping = aes(x = factor(a), y = dist_to_theo_val)
) +
  geom_violin(
    mapping = aes(fill = type)
  ) +
  geom_hline(yintercept = 0, colour = "darkred", linetype = "dashed") +
  theme_paper() +
  facet_wrap(~type, scales = "free_x", ncol = 2) +
  scale_fill_manual(
    NULL,
    values = c(
      "AIPW" = "#56B4E9", 
      "IPW" = "gray",
      "CausalMed" = "#E69F00",
      "OT" = "#CC79A7", 
      "Seq OT (1)" = "#009E73", 
      "Seq OT (2)" = "#D55E00"
    )
  ) +
  theme(legend.position = "bottom") +
  labs(
    x = latex2exp::TeX("Distance $\\alpha$"),
    y = "Distance to theoretical natural direct effect",
  ) +
  scale_x_discrete(
    labels = ifelse(unique(data_plot$a) %% .5 == 0, unique(data_plot$a), "")
  )
```


:::