# Monte Carlo Simulations {#sec-gaussian-ex-simul}


:::{.callout-note}

## Objectives

In this chapter, XXX



:::

:::{.callout-important}

These are preliminary results with only 9 replications per simulation. The MC simulations will be run this evening.

:::

```{r package-settings}
#| warning: false
#| message: false
library(tidyverse)
library(mnormt)
```

```{r}
#| warning: false
#| message: false
#| code-fold: true
#| code-summary: Codes for graphical parameters
library(extrafont, quietly = TRUE)
col_group <- c("#00A08A","#F2AD00", "#1b95e0")
colour_methods <- c(
    "OT" = "#CC79A7", "OT-M" = "#009E73",
    "skh" = "darkgray",
    "seq_1" = "#0072B2", "seq_2" = "#D55E00"
  )
colGpe1 <- col_group[2]
colGpe0 <- col_group[1]
colGpet <- col_group[3]
loadfonts(device = "pdf", quiet = TRUE)
font_size <- 20
font_family <- "CMU Serif"

path <- "./figs/"
if (!dir.exists(path)) dir.create(path)

source("../scripts/utils.R")
```



```{r}
#| echo: false
#| eval: true
#| message: false
#| warning: false
#| file: _myfunctions.R
```

$$
\definecolor{wongBlack}{RGB}{0,0,0}
\definecolor{wongGold}{RGB}{230, 159, 0}
\definecolor{wongLightBlue}{RGB}{86, 180, 233}
\definecolor{wongGreen}{RGB}{0, 158, 115}
\definecolor{wongYellow}{RGB}{240, 228, 66}
\definecolor{wongBlue}{RGB}{0, 114, 178}
\definecolor{wongOrange}{RGB}{213, 94, 0}
\definecolor{wongPurple}{RGB}{204, 121, 167}
\definecolor{colGpe1}{RGB}{0, 160, 138}
\definecolor{colGpe0}{RGB}{242, 173, 0}
$$

## Functions

Let us redefine the function shown in [Chapter -@sec-motivation-gaussian] that will be used to perform the simulations here.

```{r}
#| code-fold: true
#| code-summary: Functions used to generate the data (`gen_data()`{.R}), create counterfactuals with optimal transport (`compute_ot_map()`{.R}, `apply_ot_transport()`{.R}) and sequential transport (`sequential_transport_12()`{.R}, `sequential_transport_21()`{.R}), compute the total causal effect based on (`causal_effects_cf()`{.R})
## Data----

#' @param n0 Number of units in group 0.
#' @param n1 Number of units in group 1.
#' @param mu0 Mean of the two covariates in group 0.
#' @param mu1 Mean of the two covariates in group 1.
#' @param r0 Covariance of the two covariates in group 0.
#' @param r1 Covariance of the two covariates in group 1.
#' @param a Shift parameter for the mean in both groups (default to 1: no shift). Larger values decrease overlap.
#' @param seed Random seed for reproducibility.
gen_data <- function(n0 = 250,
                     n1 = 250,
                     mu0 = -1,
                     mu1 = +1,
                     r0 = +.7,
                     r1 = -.5,
                     a = 1,
                     seed = NULL) {
  
  if (!is.null(seed)) set.seed(seed)
  
  a0 <- 3
  a1 <- 2
  a2 <- -1.5
  Mu0 <- rep(mu0, 2)
  Mu1 <- rep(mu1, 2)
  Sig0 <- matrix(c(1, r0, r0, 1), 2, 2)
  Sig1 <- matrix(c(1, r1, r1, 1), 2, 2)
  
  # Generate covariates for each group
  X0 <- rmnorm(n0, mean = a * Mu0, varcov = Sig0)
  X1 <- rmnorm(n1, mean = a * Mu1, varcov = Sig1)
  # Combine into a single covariate matrix
  X <- rbind(X0, X1)
  # Treatment indicator: 0 for first n0, 1 for next n1
  A <- c(rep(0, n0), rep(1, n1))
  # Random noise for each unit
  E <- rnorm(n0 + n1)
  
  # Outcomes
  Y0 <- a1 * X[, 1] + a2 * X[, 2] + E
  Y1 <- a1 * X[, 1] + a2 * X[, 2] + a0 + E
  Y <- A * Y1 + (1 - A) * Y0
  
  df <- tibble(
    X1 = X[, 1],
    X2 = X[, 2],
    A = A,
    Y0 = Y0,
    Y1 = Y1,
    Y  = Y
  )
  
  df
}

## Optimal Transport----

#' Optimal transport mapping between two Gaussian distributions 
#'  (from \eqn{\mathcal{N}(\mu_{\text{source}}, \Sigma_{\text{source}})} to 
#'   \eqn{\mathcal{N}(\mu_{\text{target}}, \Sigma_{\text{target}})})
#'  
#' @param mu_source Mean vector of the source Gaussian.
#' @param sigma_source Covariance matrix of the source Gaussian.
#' @param mu_target Mean vector of the target Gaussian.
#' @param sigma_target Covariance matrix of the target Gaussian.
compute_ot_map <- function(mu_source, sigma_source, mu_target, sigma_target) {
  sqrt_sigma_source <- sqrtm(sigma_source)
  sqrt_sigma_source_inv <- solve(sqrt_sigma_source)
  
  inner <- sqrt_sigma_source %*% sigma_target %*% sqrt_sigma_source
  sqrt_inner <- sqrtm(inner)
  
  A <- sqrt_sigma_source_inv %*% sqrt_inner %*% sqrt_sigma_source_inv
  
  list(A = A, shift = mu_target - A %*% mu_source)
}

#' Function to apply the transport map to simulated data
#' 
#' @param X Observations to transport.
#' @param mapping Optimal transport mapping (from `compute_ot_map()`)?
apply_ot_transport <- function(X, mapping) {
  A <- mapping$A
  shift <- mapping$shift
  t(apply(X, 1, function(x) as.vector(shift + A %*% x)))
}

## Penalized Transport----
#' @param X_source Matrix of observations to transport from the source group.
#' @param X_target Matrix of observations from the target group.
#' @param gamma A regularization parameter (default to 0.1).
transport_regul <- function(X_source, 
                            X_target, 
                            gamma) {

  X_source <- as.matrix(X_source)
  X_target <- as.matrix(X_target)
  n_source <- nrow(X_source)
  n_target <- nrow(X_target)
  # Uniform weights
  w_source <- rep(1 / n_source, n_source)
  w_target <- rep(1 / n_target, n_target)
  
  # Pairwise squared Euclidean distance
  cost_mat <- as.matrix(dist(rbind(X_source, X_target)))^2
  C <- cost_mat[1:n_source, (n_source + 1):(n_source + n_target)]
  
  # Run Sinkhorn with entropic regularization gamma
  skh_res <- T4transport::sinkhornD(
    D = C, p = 2, wx = w_source, wy = w_target, lambda = gamma
  )

  # Extract and normalize plan
  ot_plan_skh <- skh_res$plan
  ot_plan_skh <- sweep(ot_plan_skh, 1, rowSums(ot_plan_skh), FUN = "/")
  
  ot_plan_skh %*% X_target
}

## Transport Many-to-one----

#' @param X_source Source characteristics
#' @param X_target Target characteristics
#' @param method Algorithm to use for transport
transport_many_to_one <- function(X_source, 
                                  X_target, 
                                  method = "shortsimplex") {
  n_source <- nrow(X_source)
  n_target <- nrow(X_target)
  
  # Uniform weights
  w_source <- rep(1 / n_source, n_source)
  w_target <- rep(1 / n_target, n_target)
  
  # Cost matrix
  cost <- as.matrix(dist(rbind(X_source, X_target)))
  cost <- cost[1:n_source, (n_source + 1):(n_source + n_target)]
  
  # Solve OT plan
  ot_plan <- transport::transport(
    w_source, w_target, costm = cost, method = method
  )
  
  # For each source unit, select the target with the highest mass
  best_match <- ot_plan |>
    dplyr::group_by(from) |>
    dplyr::slice_max(mass, n = 1, with_ties = FALSE) |>
    dplyr::ungroup()
  
  # Matched matrix
  X_matched <- X_target[best_match$to, , drop = FALSE]
  
  X_matched
}

## Sequential Optimal Transport----

#' Sequential transport from N(M_source, S_source) to N(M_target, S_target),
#' along X1, then X2 | X1
#'
#' @param X n x 2 matrix of source observations.
#' @param M_source Mean vector of the source distribution (length 2).
#' @param S_source Covariance matrix of the source distribution (2x2).
#' @param M_target Mean vector of the target distribution.
#' @param S_target Covariance matrix of the target distribution.
sequential_transport_12 <- function(X, 
                                    M_source, 
                                    S_source, 
                                    M_target, 
                                    S_target) {
  
  # marginal univariate transport along the first coordinate (X_1)
  T1x <- qnorm(
    pnorm(X[, 1], mean = M_source[1], sd = sqrt(S_source[1, 1])),
    mean = M_target[1], sd = sqrt(S_target[1, 1])
  )
  
  # conditional parameters for X_2 | X_1
  m_source <- M_source[2] + S_source[1, 2] / S_source[1, 1] * (X[, 1] - M_source[1])
  s_source <- S_source[2, 2] - S_source[1, 2]^2 / S_source[1, 1]
  
  m_target <- M_target[2] + S_target[1, 2] / S_target[1, 1] * (T1x - M_target[1])
  s_target <- S_target[2, 2] - S_target[1, 2]^2 / S_target[1, 1]
  
  # conditional transport for the second coordinate
  T2x <- qnorm(
    pnorm(X[, 2], mean = m_source, sd = sqrt(s_source)),
    mean = m_target, sd = sqrt(s_target)
  )
  
  cbind(T1x, T2x)
}

#' Sequential transport from N(M_source, S_source) to N(M_target, S_target),
#' along X2, then X1 | X2
#'
#' @param X n x 2 matrix of source observations.
#' @param M_source Mean vector of the source distribution (length 2).
#' @param S_source Covariance matrix of the source distribution (2x2).
#' @param M_target Mean vector of the target distribution.
#' @param S_target Covariance matrix of the target distribution.
sequential_transport_21 <- function(X, M_source, S_source, M_target, S_target) {
  
  # marginal univariate transport along X_2
  T2x <- qnorm(
    pnorm(X[, 2], mean = M_source[2], sd = sqrt(S_source[2, 2])),
    mean = M_target[2], sd = sqrt(S_target[2, 2])
  )
  
  # conditional parameters for X_1 | X_2
  m_source <- M_source[1] + S_source[1, 2] / S_source[2, 2] * (X[, 2] - M_source[2])
  s_source <- S_source[1, 1] - S_source[1, 2]^2 / S_source[2, 2]
  
  m_target <- M_target[1] + S_target[1, 2] / S_target[2, 2] * (T2x - M_target[2])
  s_target <- S_target[1, 1] - S_target[1, 2]^2 / S_target[2, 2]
  
  # conditional transport for X1 | X_2
  T1x <- qnorm(
    pnorm(X[, 1], mean = m_source, sd = sqrt(s_source)),
    mean = m_target, sd = sqrt(s_target)
  )
  
  cbind(T1x, T2x)
}

## Causal Effect----
#' Estimation of total causal effect using counterfactuals.
#' 
#' @param data_untreated Dataset with the untreated units only.
#' @param data_treated Dataset with the treated units only.
#' @param data_cf_untreated Counterfactuals for untreated had they been treated.
#' @param data_cf_treated Counterfactuals for treated had they been untreated.
#' @param Y_name Name of the column with the outcome variable.
#' @param A_name Name of the column with the treatment variable.
#' @param A_untreated Value of the treatment for the untreated units.
#' 
#' @returns A list:
#' - `delta_0_i`: \eqn{\delta_(0)}, individual causal mediation effects for 
#'   \eqn{a=0} (computed on untreated),
#' - `delta_0`: \eqn{\bar{\delta}(0)}, average causal mediation effect for 
#'   \eqn{a=0} (computed on untreated),
#' - `delta_1_i`: \eqn{\delta_(1)}, individual causal mediation effects for 
#'   \eqn{a=1} (computed on treated),
#' - `delta_1`: \eqn{\bar{\delta}(1)}, average causal mediation effect for 
#'   \eqn{a=1} (computed on treated),
#' - `zeta_0_i`: \eqn{\zeta_(0)}, individual causal mediation effects for 
#'   \eqn{a=0} (computed on treaded),
#' - `zeta_0`: \eqn{\bar{\zeta}(0)}, average causal mediation effect for 
#'   \eqn{a=0} (computed on treated),
#' - `zeta_1_i`: \eqn{\zeta_(1)}, individual causal mediation effects for 
#'   \eqn{a=1} (computed on untreaded),
#' - `zeta_1`: \eqn{\bar{\zeta}(1)}, average causal mediation effect for 
#'   \eqn{a=1} (computed on untreated),
#' - `tot_effect`: \eqb{\tau}: average total effect (\eqn{\bar{\delta}(0) + 
#'   \bar{\zeta}(1)}).
#'
#' @importFrom randomForest randomForest
#' @importFrom dplyr pull select
#' @importFrom stats predict
#' @md
causal_effects_cf <- function(data_untreated,
                              data_treated,
                              data_cf_untreated,
                              data_cf_treated,
                              Y_name,
                              A_name,
                              A_untreated) {
  
  n_untreated <- nrow(data_untreated)
  n_treated <- nrow(data_treated)
  
  # Outcome model for untreated
  mu_untreated_model <- randomForest(
    x = data_untreated |> dplyr::select(-!!Y_name, -!!A_name),
    y = pull(data_untreated, !!Y_name)
  )
  
  # Outcome model for treated
  mu_treated_model <- randomForest(
    x = data_treated |> dplyr::select(-!!Y_name, -!!A_name),
    y = pull(data_treated, !!Y_name)
  )
  
  # Observed outcome
  y_untreated_obs <- data_untreated |> pull(!!Y_name)
  y_treated_obs <- data_treated |> pull(!!Y_name)
  
  # Natural Indirect Effect, using predictions
  delta_0_i <- predict(mu_untreated_model, newdata = data_cf_untreated) -
    predict(mu_untreated_model)
  delta_0 <- mean(delta_0_i)
  delta_1_i <- predict(mu_treated_model) - 
    predict(mu_treated_model, newdata = data_cf_treated)
  delta_1 <- mean(delta_1_i)

  # Natural Indirect Effect, using observed variables
  delta_0_i_obs <- predict(mu_untreated_model, newdata = data_cf_untreated) - 
    y_untreated_obs
  delta_0_obs <- mean(delta_0_i_obs)
  delta_1_i_obs <- y_treated_obs - 
    predict(mu_treated_model, newdata = data_cf_treated)
  delta_1_obs <- mean(delta_1_i_obs)
  
  # Natural Direct Effect (only predictions)
  zeta_0_i <- predict(mu_treated_model, newdata = data_cf_treated) -
    predict(mu_untreated_model, newdata = data_cf_treated)
  zeta_0 <- mean(zeta_0_i)
  
  zeta_1_i <- predict(mu_treated_model, newdata = data_cf_untreated) - 
    predict(mu_untreated_model, newdata = data_cf_untreated)
  zeta_1 <- mean(zeta_1_i)
  
  # Total Causal Effect for treated
  tot_effect <- delta_0 + zeta_1  
  tot_effect_obs <- delta_0_obs + zeta_1
  
  
  list(
    delta_0_i = delta_0_i,
    delta_1_i = delta_1_i,
    zeta_0_i = zeta_0_i,
    zeta_1_i = zeta_1_i,
    delta_0_i_obs = delta_0_i_obs,
    delta_1_i_obs = delta_1_i_obs,
    delta_0 = delta_0,
    delta_1 = delta_1,
    zeta_0 = zeta_0,
    zeta_1 = zeta_1,
    delta_0_obs = delta_0_obs,
    delta_1_obs = delta_1_obs,
    tot_effect = tot_effect,
    tot_effect_obs = tot_effect_obs
  )
}
```

We define the function `sim_f()`{.R} to run a single replication of the Monte-Carlo simulations. This functions proceeds in the following steps:

1. Generate data depending on the provided parameters for the DGP,
2. Build Counterfactuals (with optimal transport and with sequential optimal transport) of units from the untreated group ($A=0$), as well as units from the treated group ($A=1$),
3. Compute the total causal effect.

```{r sim_f}
sim_f <- function(n0 = 250,
                  n1 = 250,
                  mu0, 
                  mu1, 
                  r0, 
                  r1, 
                  a, 
                  seed = NULL) {
  
  if (!is.null(seed)) set.seed(seed)
  
  # 1. Generate data
  df <- gen_data(
    n0 = n0,
    n1 = n1,
    mu0 = mu0, 
    mu1 = mu1, 
    r0 = r0, 
    r1 = r1,
    a = a, 
    seed = seed
  )
  
  # 2. Building Counterfactuals
  
  ## With Optimal Transport
  # Transporting map for source: group 1, target: group 0 (careful here)
  Sigma0 <- matrix(c(1, r0, r0, 1), 2, 2)
  Sigma1 <- matrix(c(1, r1, r1, 1), 2, 2)
  Mu0 <- rep(a * mu0, 2)
  Mu1 <- rep(a * mu1, 2)
  
  # Mapping from group 0 to group 1
  ot_map_0_to_1 <- compute_ot_map(
    mu_source = Mu0, sigma_source = Sigma0, 
    mu_target = Mu1, sigma_target = Sigma1
  )
  # Mapping from group 1 to group 0
  ot_map_1_to_0 <- compute_ot_map(
    mu_source = Mu1, sigma_source = Sigma0, 
    mu_target = Mu0, sigma_target = Sigma0
  )  
  
  # Apply transport map to treated units (A = 1)
  X0 <- as.matrix(df[df$A == 0, c("X1", "X2")])
  X1 <- as.matrix(df[df$A == 1, c("X1", "X2")])
  X0_t <- apply_ot_transport(X = X0, mapping = ot_map_0_to_1)
  colnames(X0_t) <- c(c("X1", "X2"))
  X1_t <- apply_ot_transport(X = X1, mapping = ot_map_1_to_0)
  colnames(X1_t) <- c(c("X1", "X2"))
  
  # With OT-Matching
  X0_tmatch <- transport_many_to_one(X_source = X0, X_target = X1)
  X1_tmatch <- transport_many_to_one(X_source = X1, X_target = X0)
  
  ## With Entropy regularized transport
  # Transport from group 0 to group 1:
  X0_skh <- transport_regul(
    X_source = X0, 
    X_target = X1, 
    gamma = 0.1
  )
  # Transport from group 1 to group 0:
  X1_skh <- transport_regul(
    X_source = X1, 
    X_target = X0, 
    gamma = 0.1
  )
  
  ## With Sequential Transport
  # Transport from group 0 to group 1: X1 then X2 | X1
  X0_st_12 <- sequential_transport_12(
    X = X0, M_source = Mu0, S_source = Sigma0, M_target = Mu1, S_target = Sigma1
  )
  # Transport from group 1 to group 0: X1 then X2 | X1
  X1_st_12 <- sequential_transport_12(
    X = X1, M_source = Mu1, S_source = Sigma1, M_target = Mu0, S_target = Sigma0
  )
  # Transport from group 0 to group 1: X2 then X1 | X2
  X0_st_21 <- sequential_transport_21(
    X = X0, M_source = Mu0, S_source = Sigma0, M_target = Mu1, S_target = Sigma1
  )
  # Transport from group 1 to group 0: X2 then X1 | X2
  X1_st_21 <- sequential_transport_21(
    X = X1, M_source = Mu1, S_source = Sigma1, M_target = Mu0, S_target = Sigma0
  )
  
  # 3. Measuring Total Causal Effect
  tb <- df[, c("Y", "A", "X1", "X2")]
  A_name <- "A"
  A_untreated <- 0
  Y_name <- "Y"
  
  # Causal Mediation Analysis
  med_mod_12 <- mediation::multimed(
    outcome = "Y", 
    med.main = "X1", 
    med.alt = "X2", 
    treat = "A", 
    data = df
  )
  med_mod_21 <- mediation::multimed(
    outcome = "Y", 
    med.main = "X2", 
    med.alt = "X1", 
    treat = "A", 
    data = df
  )
  
  delta_0_med <- mean((med_mod_12$d0.lb + med_mod_12$d0.ub) / 2) +
    mean((med_mod_21$d0.lb + med_mod_21$d0.ub) / 2)
  delta_1_med <- mean((med_mod_12$d1.lb + med_mod_12$d1.ub) / 2) + 
    mean((med_mod_21$d1.lb + med_mod_21$d1.ub) / 2)
  tot_effect_med <- med_mod_12$tau
  zeta_0_med <- tot_effect_med - delta_1_med
  zeta_1_med <- tot_effect_med-delta_0_med
  
  # With OT counterfactuals
  tb_untreated <- tb |> filter(!!sym(A_name) == !!A_untreated)
  tb_treated <- tb |> filter(!!sym(A_name) != !!A_untreated)
  
  causal_effects_ot <- causal_effects_cf(
    data_untreated = tb_untreated, 
    data_treated = tb_treated,
    data_cf_untreated = as_tibble(X0_t),
    data_cf_treated = as_tibble(X1_t),
    Y_name = Y_name, 
    A_name = A_name, 
    A_untreated = A_untreated
  )
  
  # With OT-Matching counterfactuals
  causal_effects_tmatch <- causal_effects_cf(
    data_untreated = tb_untreated, 
    data_treated = tb_treated,
    data_cf_untreated = as_tibble(X0_tmatch),
    data_cf_treated = as_tibble(X1_tmatch),
    Y_name = Y_name, 
    A_name = A_name, 
    A_untreated = A_untreated
  )
  
  # With entropy regularized transport
  causal_effects_skh <- causal_effects_cf(
    data_untreated = tb_untreated, 
    data_treated = tb_treated,
    data_cf_untreated = as_tibble(X0_skh),
    data_cf_treated = as_tibble(X1_skh),
    Y_name = Y_name, 
    A_name = A_name, 
    A_untreated = A_untreated
  )
  
  # With Sequential Transport counterfactuals
  causal_effect_sot_12 <- causal_effects_cf(
    data_untreated = tb_untreated, 
    data_treated = tb_treated,
    data_cf_untreated = as_tibble(X0_st_12) |> magrittr::set_colnames(c("X1", "X2")),
    data_cf_treated = as_tibble(X1_st_12) |> magrittr::set_colnames(c("X1", "X2")),
    Y_name = Y_name, 
    A_name = A_name, 
    A_untreated = A_untreated
  )
  causal_effect_sot_21 <- causal_effects_cf(
    data_untreated = tb_untreated, 
    data_treated = tb_treated,
    data_cf_untreated = as_tibble(X0_st_21) |> magrittr::set_colnames(c("X1", "X2")),
    data_cf_treated = as_tibble(X1_st_21) |> magrittr::set_colnames(c("X1", "X2")),
    Y_name = Y_name, 
    A_name = A_name, 
    A_untreated = A_untreated
  )
  
  tibble(
    # Mediation
    delta_0_med = delta_0_med,
    delta_1_med = delta_1_med,
    zeta_0_med = zeta_0_med,
    zeta_1_med = zeta_1_med,
    tot_effect_med = tot_effect_med,
    # OT
    delta_0_ot = causal_effects_ot$delta_0,
    delta_1_ot = causal_effects_ot$delta_1,
    delta_0_ot_obs = causal_effects_ot$delta_0_obs,
    delta_1_ot_obs = causal_effects_ot$delta_1_obs,
    zeta_0_ot = causal_effects_ot$zeta_0,
    zeta_1_ot = causal_effects_ot$zeta_1,
    tot_effect_ot = causal_effects_ot$tot_effect,
    tot_effect_ot_obs = causal_effects_ot$tot_effect_obs,
    # OT-M
    delta_0_tmatch = causal_effects_tmatch$delta_0,
    delta_1_tmatch = causal_effects_tmatch$delta_1,
    delta_0_tmatch_obs = causal_effects_tmatch$delta_0_obs,
    delta_1_tmatch_obs = causal_effects_tmatch$delta_1_obs,
    zeta_0_tmatch = causal_effects_tmatch$zeta_0,
    zeta_1_tmatch = causal_effects_tmatch$zeta_1,
    tot_effect_tmatch = causal_effects_tmatch$tot_effect,
    tot_effect_tmatch_obs = causal_effects_tmatch$tot_effect_obs,
    # SKH
    delta_0_skh = causal_effects_skh$delta_0,
    delta_1_skh = causal_effects_skh$delta_1,
    delta_0_skh_obs = causal_effects_skh$delta_0_obs,
    delta_1_skh_obs = causal_effects_skh$delta_1_obs,
    zeta_0_skh = causal_effects_skh$zeta_0,
    zeta_1_skh = causal_effects_skh$zeta_1,
    tot_effect_skh = causal_effects_skh$tot_effect,
    tot_effect_skh_obs = causal_effects_skh$tot_effect_obs,
    # SOT 12
    delta_0_sot_12 = causal_effect_sot_12$delta_0,
    delta_1_sot_12 = causal_effect_sot_12$delta_1,
    delta_0_sot_12_obs = causal_effect_sot_12$delta_0_obs,
    delta_1_sot_12_obs = causal_effect_sot_12$delta_1_obs,
    zeta_0_sot_12 = causal_effect_sot_12$zeta_0,
    zeta_1_sot_12 = causal_effect_sot_12$zeta_1,
    tot_effect_sot_12 = causal_effect_sot_12$tot_effect,
    tot_effect_sot_12_obs = causal_effect_sot_12$tot_effect_obs,
    # SOT 21
    delta_0_sot_21 = causal_effect_sot_21$delta_0,
    delta_1_sot_21 = causal_effect_sot_21$delta_1,
    delta_0_sot_21_obs = causal_effect_sot_21$delta_0_obs,
    delta_1_sot_21_obs = causal_effect_sot_21$delta_1_obs,
    zeta_0_sot_21 = causal_effect_sot_21$zeta_0,
    zeta_1_sot_21 = causal_effect_sot_21$zeta_1,
    tot_effect_sot_21 = causal_effect_sot_21$tot_effect,
    tot_effect_sot_21_obs = causal_effect_sot_21$tot_effect_obs,
    n0 = n0,
    n1 = n1,
    seed = seed,
    mu0 = mu0,
    mu1 = mu1,
    r0 = r0,
    r1 = r1,
    a = a
  )
}
```

## Varying the Distance Between the Means

We make the distance between the means of the Gaussian distributions of the two groups increase. With $\boldsymbol{\mu}_0 = \begin{pmatrix}-1\\-1\end{pmatrix}$ and $\boldsymbol{\mu}_1 = \begin{pmatrix}1\\1\end{pmatrix}$, the distance is equal to $1$. We apply a scalar coefficient $a\geq 0$ to the means to increase that distance: $a\boldsymbol{\mu}_0$ and $a\boldsymbol{\mu}_1$. We make $a$ vary from 0 to 1 by steps of .1. When $a=0$, the distance is equal to $0$, when $a=2$, the distance is equal to $2$.

We define a grid with the different simulations.
```{r}
n_repl <- 200
grid_params <- expand_grid(
  n0 = 250,
  n1 = 250,
  mu0 = -1,
  mu1 = +1,
  r0 = +.7,
  r1 = -.5,
  a = seq(0, 2, by = .1),
  seed = seq_len(n_repl)
)
```

The simulations can be run in parallel, as follows.

```{r mc-simul, eval=FALSE}
# This chunk takes about XX minutes to run.
# We do not evaluate when compiling the document.
# Instead, we load previously obtained results.
library(pbapply)
library(parallel)
ncl <- detectCores()-1
(cl <- makeCluster(ncl))

clusterEvalQ(cl, {
  library(tidyverse)
  library(mnormt)
  library(expm)
  library(randomForest)
}) |>
  invisible()

clusterExport(
  cl = cl, c(
    "gen_data", "compute_ot_map", "apply_ot_transport",
    "transport_regul", "transport_many_to_one",
    "sequential_transport_12", "sequential_transport_21",
    "causal_effects_cf", "sim_f", "grid_params"
  )
)

res_sim <- pbapply::pblapply(1:nrow(grid_params), function(i) {
  
  grid_params_current <- grid_params[i, ]
  
  n0 <- grid_params_current$n0
  n1 <- grid_params_current$n1
  mu0 <- grid_params_current$mu0
  mu1 <- grid_params_current$mu1
  r0 <- grid_params_current$r0
  r1 <- grid_params_current$r1
  a <- grid_params_current$a
  seed <- grid_params_current$seed
  
  sim_f(
    n0 = n0, n1 = n1, 
    mu0 = mu0, mu1 = mu1, 
    r0 = r0, r1 = r1, 
    a = a, seed = seed
  )
}, cl = cl)

stopCluster(cl)
res_sim <- list_rbind(res_sim)

save(res_sim, file = "../output/res_sim-gaussian-mc.rda")
```

We load previously obtained results:
```{r load-results-simul}
load("../output/res_sim-gaussian-mc.rda")
```

:::{.panel-tabset}

### Total Causal Effect ($\bar{\tau}$)

```{r}
#| fig-width: 8
#| fig-height: 6
#| code-fold: true
#| code-summary: Codes to create the Figure.
a1 <- 2
a2 <- -1.5
data_plot <- res_sim |> 
  dplyr::select(
    n0, n1, seed, a, mu0, mu1,
    tot_effect_med, tot_effect_ot, tot_effect_tmatch,
    tot_effect_skh, tot_effect_sot_12, tot_effect_sot_21
  ) |> 
  pivot_longer(
    cols = c(
      tot_effect_med, tot_effect_ot, tot_effect_tmatch,
      tot_effect_skh, tot_effect_sot_12, tot_effect_sot_21
    ), 
    names_to = "type", values_to = "tau"
  ) |> 
  mutate(
    type = factor(
      type,
      levels = c(
        "tot_effect_med", "tot_effect_ot", "tot_effect_tmatch",
        "tot_effect_skh", "tot_effect_sot_12", "tot_effect_sot_21"
      ),
      labels = c("CM", "OT", "OT-M", "SKH", "ST(1)", "ST(2)")
    ),
    dist_to_causal_effect = (a1+a2) * (a*mu1 - a*mu0) + 3 - tau
  )
ggplot(
  data = data_plot,
  mapping = aes(x = factor(a), y = dist_to_causal_effect)
) +
  geom_violin(
    mapping = aes(fill = type)
  ) +
  geom_hline(yintercept = 0, colour = "darkred", linetype = "dashed") +
  theme_paper() +
  facet_wrap(~type, scales = "free_x", ncol = 2) +
  scale_fill_manual(
    NULL,
    values = c(
      "CM" = "#56B4E9",
      "OT" = colour_methods[["OT"]], 
      "OT-M" = colour_methods[["OT-M"]], 
      "SKH" = colour_methods[["skh"]], 
      "ST(1)" =  colour_methods[["seq_1"]],
      "ST(2)" =  colour_methods[["seq_2"]]
    ),
    guide = "none",
  ) +
  theme(legend.position = "bottom") +
  labs(
    x = latex2exp::TeX("Distance $\\alpha$"),
    y = "Distance to theoretical total causal effect",
  ) +
  scale_x_discrete(
    labels = ifelse(unique(data_plot$a) %% .5 == 0, unique(data_plot$a), "")
  )
```

### Natural Indirect Effect ($\delta(0)$)

```{r}
#| fig-width: 8
#| fig-height: 6
#| code-fold: true
#| code-summary: Codes to create the Figure.
data_plot <- res_sim |> 
  dplyr::select(
    n0, n1, seed, a, mu0, mu1,
    delta_0_med, delta_0_ot, delta_0_tmatch,
    delta_0_skh, delta_0_sot_12, delta_0_sot_21
  ) |> 
  pivot_longer(
    cols = c(
      delta_0_med, delta_0_ot, delta_0_tmatch,
      delta_0_skh, delta_0_sot_12, delta_0_sot_21
    ), 
    names_to = "type", values_to = "val"
  ) |> 
  mutate(
    type = factor(
      type,
      levels = c(
        "delta_0_med", "delta_0_ot", "delta_0_tmatch",
        "delta_0_skh", "delta_0_sot_12", "delta_0_sot_21"
      ),
      labels = c("CM", "OT", "OT-M", "SKH", "ST(1)", "ST(2)")
    ),
    dist_to_theo_val = ((a1+a2)*(mu1-mu0)) - val
  )
ggplot(
  data = data_plot,
  mapping = aes(x = factor(a), y = dist_to_theo_val)
) +
  geom_violin(
    mapping = aes(fill = type)
  ) +
  geom_hline(yintercept = 0, colour = "darkred", linetype = "dashed") +
  theme_paper() +
  facet_wrap(~type, scales = "free_x", ncol = 2) +
  scale_fill_manual(
    NULL,
    values = c(
      "CM" = "#56B4E9",
      "OT" = colour_methods[["OT"]], 
      "OT-M" = colour_methods[["OT-M"]], 
      "SKH" = colour_methods[["skh"]], 
      "ST(1)" =  colour_methods[["seq_1"]],
      "ST(2)" =  colour_methods[["seq_2"]]
    )
  ) +
  theme(legend.position = "bottom") +
  labs(
    x = latex2exp::TeX("Distance $\\alpha$"),
    y = "Distance to theoretical natural indirect effect",
  ) +
  scale_x_discrete(
    labels = ifelse(unique(data_plot$a) %% .5 == 0, unique(data_plot$a), "")
  )
```

### Natural Indirect Effect ($\delta(1)$)

```{r}
#| fig-width: 8
#| fig-height: 6
#| code-fold: true
#| code-summary: Codes to create the Figure.
data_plot <- res_sim |> 
  dplyr::select(
    n0, n1, seed, a, mu0, mu1,
    delta_1_med, delta_1_ot, delta_1_tmatch,
    delta_1_skh, delta_1_sot_12, delta_1_sot_21
  ) |> 
  pivot_longer(
    cols = c(
    delta_1_med, delta_1_ot, delta_1_tmatch,
    delta_1_skh, delta_1_sot_12, delta_1_sot_21), 
    names_to = "type", values_to = "val"
  ) |> 
  mutate(
    type = factor(
      type,
      levels = c(
        "delta_1_med", "delta_1_ot", "delta_1_tmatch",
        "delta_1_skh", "delta_1_sot_12", "delta_1_sot_21"
      ),
      labels = c("CM", "OT", "OT-M", "SKH", "ST(1)", "ST(2)")
    ),
    dist_to_theo_val = ((a1+a2)*(mu1-mu0)) - val
  )
ggplot(
  data = data_plot,
  mapping = aes(x = factor(a), y = dist_to_theo_val)
) +
  geom_violin(
    mapping = aes(fill = type)
  ) +
  geom_hline(yintercept = 0, colour = "darkred", linetype = "dashed") +
  theme_paper() +
  facet_wrap(~type, scales = "free_x", ncol = 2) +
  scale_fill_manual(
    NULL,
    values = c(
      "CM" = "#56B4E9",
      "OT" = colour_methods[["OT"]], 
      "OT-M" = colour_methods[["OT-M"]], 
      "SKH" = colour_methods[["skh"]], 
      "ST(1)" =  colour_methods[["seq_1"]],
      "ST(2)" =  colour_methods[["seq_2"]]
    ),
    guide = "none"
  ) +
  theme(legend.position = "bottom") +
  labs(
    x = latex2exp::TeX("Distance $\\alpha$"),
    y = "Distance to theoretical natural indirect effect",
  ) +
  scale_x_discrete(
    labels = ifelse(unique(data_plot$a) %% .5 == 0, unique(data_plot$a), "")
  )
```

### Natural Direct Effect ($\zeta(0)$)

```{r}
#| fig-width: 8
#| fig-height: 6
#| code-fold: true
#| code-summary: Codes to create the Figure.
data_plot <- res_sim |> 
  dplyr::select(
    n0, n1, seed, a, mu0, mu1,
    zeta_0_med, zeta_0_ot, zeta_0_tmatch,
    zeta_0_skh, zeta_0_sot_12, zeta_0_sot_21
  ) |> 
  pivot_longer(
    cols = c(zeta_0_med, zeta_0_ot, zeta_0_tmatch,
    zeta_0_skh, zeta_0_sot_12, zeta_0_sot_21), 
    names_to = "type", values_to = "val"
  ) |> 
  mutate(
    type = factor(
      type,
      levels = c(
        "zeta_0_med", "zeta_0_ot", "zeta_0_tmatch",
        "zeta_0_skh", "zeta_0_sot_12", "zeta_0_sot_21"
      ),
      labels = c("CM", "OT", "OT-M", "SKH", "ST(1)", "ST(2)")
    ),
    dist_to_theo_val = 3 - val
  )
ggplot(
  data = data_plot,
  mapping = aes(x = factor(a), y = dist_to_theo_val)
) +
  geom_violin(
    mapping = aes(fill = type)
  ) +
  geom_hline(yintercept = 0, colour = "darkred", linetype = "dashed") +
  theme_paper() +
  facet_wrap(~type, scales = "free_x", ncol = 2) +
  scale_fill_manual(
    NULL,
    values = c(
      "CM" = "#56B4E9",
      "OT" = colour_methods[["OT"]], 
      "OT-M" = colour_methods[["OT-M"]], 
      "SKH" = colour_methods[["skh"]], 
      "ST(1)" =  colour_methods[["seq_1"]],
      "ST(2)" =  colour_methods[["seq_2"]]
    ),
    guide = "none"
  ) +
  theme(legend.position = "bottom") +
  labs(
    x = latex2exp::TeX("Distance $\\alpha$"),
    y = "Distance to theoretical natural direct effect",
  ) +
  scale_x_discrete(
    labels = ifelse(unique(data_plot$a) %% .5 == 0, unique(data_plot$a), "")
  )
```

### Natural Direct Effect ($\zeta(1)$)

```{r}
#| fig-width: 8
#| fig-height: 6
#| code-fold: true
#| code-summary: Codes to create the Figure.
data_plot <- res_sim |> 
  dplyr::select(
    n0, n1, seed, a, mu0, mu1,
    zeta_1_med, zeta_1_ot, zeta_1_tmatch,
    zeta_1_skh, zeta_1_sot_12, zeta_1_sot_21
  ) |> 
  pivot_longer(
    cols = c(
    zeta_1_med, zeta_1_ot, zeta_1_tmatch,
    zeta_1_skh, zeta_1_sot_12, zeta_1_sot_21), 
    names_to = "type", values_to = "val"
  ) |> 
  mutate(
    type = factor(
      type,
      levels = c(
        "zeta_1_med", "zeta_1_ot", "zeta_1_tmatch",
        "zeta_1_skh", "zeta_1_sot_12", "zeta_1_sot_21"
      ),
      labels = c("CM", "OT", "OT-M", "SKH", "ST(1)", "ST(2)")
    ),
    dist_to_theo_val = 3 - val
  )
ggplot(
  data = data_plot,
  mapping = aes(x = factor(a), y = dist_to_theo_val)
) +
  geom_violin(
    mapping = aes(fill = type)
  ) +
  geom_hline(yintercept = 0, colour = "darkred", linetype = "dashed") +
  theme_paper() +
  facet_wrap(~type, scales = "free_x", ncol = 2) +
  scale_fill_manual(
    NULL,
    values = c(
      "CM" = "#56B4E9",
      "OT" = colour_methods[["OT"]], 
      "OT-M" = colour_methods[["OT-M"]], 
      "SKH" = colour_methods[["skh"]], 
      "ST(1)" =  colour_methods[["seq_1"]],
      "ST(2)" =  colour_methods[["seq_2"]]
    ),
    guide = "none"
  ) +
  theme(legend.position = "bottom") +
  labs(
    x = latex2exp::TeX("Distance $\\alpha$"),
    y = "Distance to theoretical natural direct effect",
  ) +
  scale_x_discrete(
    labels = ifelse(unique(data_plot$a) %% .5 == 0, unique(data_plot$a), "")
  )
```
:::


## Varying the Proportion of 0s and 1s

In this section, we let the proportion of untreated/treated units vary from 5% of 0s to 95% of them. Note that we go back to the distance between the mean equal to 1, as in @sec-motivation-gaussian.

We define a grid with the different simulations.
```{r define-grid_params-prop}
grid_params <- expand_grid(
  prop_0 = seq(5, 95, by = 5)/100,
  mu0 = -1,
  mu1 = +1,
  r0 = +.7,
  r1 = -.5,
  a = 1,
  seed = seq_len(n_repl)
)
```

The simulations can be run in parallel, as follows.

```{r mc-simul-prop, eval=FALSE}
# This chunk takes about XX minutes to run.
# We do not evaluate when compiling the document.
# Instead, we load previously obtained results.
library(pbapply)
library(parallel)
ncl <- detectCores()-1
(cl <- makeCluster(ncl))

clusterEvalQ(cl, {
  library(tidyverse)
  library(mnormt)
  library(expm)
  library(randomForest)
}) |>
  invisible()

clusterExport(
  cl = cl, c(
    "gen_data", "compute_ot_map", "apply_ot_transport",
    "transport_regul", "transport_many_to_one",
    "sequential_transport_12", "sequential_transport_21",
    "causal_effects_cf", "sim_f", "grid_params"
  )
)

res_sim_prop <- pbapply::pblapply(
  1:nrow(grid_params), function(i) {
  
    grid_params_current <- grid_params[i, ]
    
    n <- 500
    prop_0 <- grid_params_current$prop_0
    n0 <- prop_0 * n
    n1 <- n - n0
    mu0 <- grid_params_current$mu0
    mu1 <- grid_params_current$mu1
    r0 <- grid_params_current$r0
    r1 <- grid_params_current$r1
    a <- grid_params_current$a
    seed <- grid_params_current$seed
    
    sim_f(
      n0 = n0, n1 = n1, 
      mu0 = mu0, mu1 = mu1, 
      r0 = r0, r1 = r1, 
      a = a, seed = seed
    ) |> 
    mutate(prop_0 = prop_0)
}, cl = cl)


stopCluster(cl)
res_sim_prop <- list_rbind(res_sim_prop)

save(
    res_sim_prop, 
    file = "../output/res_sim_prop-gaussian-mc.rda"
)
```

We load previously obtained results:
```{r load-res_sim_prop-simul}
load("../output/res_sim_prop-gaussian-mc.rda")
```

:::{.panel-tabset}

### Total Causal Effect ($\bar{\tau}$)

```{r}
#| fig-width: 8
#| fig-height: 6
#| code-fold: true
#| code-summary: Codes to create the Figure.
a1 <- 2
a2 <- -1.5
data_plot <- res_sim_prop |> 
  dplyr::select(
    n0, n1, seed, a, mu0, mu1, prop_0,
    tot_effect_med, tot_effect_ot, tot_effect_tmatch,
    tot_effect_skh, tot_effect_sot_12, tot_effect_sot_21
  ) |> 
  pivot_longer(
    cols = c(
      tot_effect_med, tot_effect_ot, tot_effect_tmatch,
      tot_effect_skh, tot_effect_sot_12, tot_effect_sot_21
    ), 
    names_to = "type", values_to = "tau"
  ) |> 
  mutate(
    type = factor(
      type,
      levels = c(
        "tot_effect_med", "tot_effect_ot", "tot_effect_tmatch",
        "tot_effect_skh", "tot_effect_sot_12", "tot_effect_sot_21"
      ),
      labels = c("CM", "OT", "OT-M", "SKH", "ST(1)", "ST(2)")
    ),
    dist_to_causal_effect = (a1+a2) * (a*mu1 - a*mu0) + 3 - tau
  )

ggplot(
  data = data_plot,
  mapping = aes(x = factor(prop_0), y = dist_to_causal_effect)
) +
  geom_violin(
    mapping = aes(fill = type)
  ) +
  geom_hline(yintercept = 0, colour = "darkred", linetype = "dashed") +
  theme_paper() +
  facet_wrap(~type, scales = "free_x", ncol = 2) +
  scale_fill_manual(
    NULL,
    values = c(
      "CM" = "#56B4E9",
      "OT" = colour_methods[["OT"]], 
      "OT-M" = colour_methods[["OT-M"]], 
      "SKH" = colour_methods[["skh"]], 
      "ST(1)" =  colour_methods[["seq_1"]],
      "ST(2)" =  colour_methods[["seq_2"]]
    ),
    guide = "none",
  ) +
  theme(legend.position = "bottom") +
  labs(
    x = "Proportion of 0s",
    y = "Distance to theoretical total causal effect",
  ) + 
  scale_x_discrete(
    labels = ifelse(
      (unique(data_plot$prop_0)*100) %% 10 == 0, 
      yes = unique(data_plot$prop_0), no = "")
  )
```

### Natural Indirect Effect ($\delta(0)$)

```{r}
#| fig-width: 8
#| fig-height: 6
#| code-fold: true
#| code-summary: Codes to create the Figure.
data_plot <- res_sim_prop |> 
  dplyr::select(
    n0, n1, seed, a, mu0, mu1, prop_0,
    delta_0_med, delta_0_ot, delta_0_tmatch,
    delta_0_skh, delta_0_sot_12, delta_0_sot_21
  ) |> 
  pivot_longer(
    cols = c(
      delta_0_med, delta_0_ot, delta_0_tmatch,
      delta_0_skh, delta_0_sot_12, delta_0_sot_21
    ), 
    names_to = "type", values_to = "val"
  ) |> 
  mutate(
    type = factor(
      type,
      levels = c(
        "delta_0_med", "delta_0_ot", "delta_0_tmatch",
        "delta_0_skh", "delta_0_sot_12", "delta_0_sot_21"
      ),
      labels = c("CM", "OT", "OT-M", "SKH", "ST(1)", "ST(2)")
    ),
    dist_to_theo_val = ((a1+a2)*(mu1-mu0)) - val
  )
ggplot(
  data = data_plot,
  mapping = aes(x = factor(prop_0), y = dist_to_theo_val)
) +
  geom_violin(
    mapping = aes(fill = type)
  ) +
  geom_hline(yintercept = 0, colour = "darkred", linetype = "dashed") +
  theme_paper() +
  facet_wrap(~type, scales = "free_x", ncol = 2) +
  scale_fill_manual(
    NULL,
    values = c(
      "CM" = "#56B4E9",
      "OT" = colour_methods[["OT"]], 
      "OT-M" = colour_methods[["OT-M"]], 
      "SKH" = colour_methods[["skh"]], 
      "ST(1)" =  colour_methods[["seq_1"]],
      "ST(2)" =  colour_methods[["seq_2"]]
    )
  ) +
  theme(legend.position = "bottom") +
  labs(
    x = "Proportion of 0",
    y = "Distance to theoretical natural indirect effect",
  ) +
  scale_x_discrete(
    labels = ifelse(
      (unique(data_plot$prop_0)*100) %% 10 == 0, 
      yes = unique(data_plot$prop_0), no = "")
  )
```

### Natural Indirect Effect ($\delta(1)$)

```{r}
#| fig-width: 8
#| fig-height: 6
#| code-fold: true
#| code-summary: Codes to create the Figure.
data_plot <- res_sim_prop |> 
  dplyr::select(
    n0, n1, seed, a, mu0, mu1, prop_0,
    delta_1_med, delta_1_ot, delta_1_tmatch,
    delta_1_skh, delta_1_sot_12, delta_1_sot_21
  ) |> 
  pivot_longer(
    cols = c(
    delta_1_med, delta_1_ot, delta_1_tmatch,
    delta_1_skh, delta_1_sot_12, delta_1_sot_21), 
    names_to = "type", values_to = "val"
  ) |> 
  mutate(
    type = factor(
      type,
      levels = c(
        "delta_1_med", "delta_1_ot", "delta_1_tmatch",
        "delta_1_skh", "delta_1_sot_12", "delta_1_sot_21"
      ),
      labels = c("CM", "OT", "OT-M", "SKH", "ST(1)", "ST(2)")
    ),
    dist_to_theo_val = ((a1+a2)*(mu1-mu0)) - val
  )
ggplot(
  data = data_plot,
  mapping = aes(x = factor(prop_0), y = dist_to_theo_val)
) +
  geom_violin(
    mapping = aes(fill = type)
  ) +
  geom_hline(yintercept = 0, colour = "darkred", linetype = "dashed") +
  theme_paper() +
  facet_wrap(~type, scales = "free_x", ncol = 2) +
  scale_fill_manual(
    NULL,
    values = c(
      "CM" = "#56B4E9",
      "OT" = colour_methods[["OT"]], 
      "OT-M" = colour_methods[["OT-M"]], 
      "SKH" = colour_methods[["skh"]], 
      "ST(1)" =  colour_methods[["seq_1"]],
      "ST(2)" =  colour_methods[["seq_2"]]
    ),
    guide = "none"
  ) +
  theme(legend.position = "bottom") +
  labs(
    x = "Proportion of 0",
    y = "Distance to theoretical natural indirect effect",
  ) +
  scale_x_discrete(
    labels = ifelse(
      (unique(data_plot$prop_0)*100) %% 10 == 0, 
      yes = unique(data_plot$prop_0), no = "")
  )
```

### Natural Direct Effect ($\zeta(0)$)

```{r}
#| fig-width: 8
#| fig-height: 6
#| code-fold: true
#| code-summary: Codes to create the Figure.
data_plot <- res_sim_prop |> 
  dplyr::select(
    n0, n1, seed, a, mu0, mu1, prop_0,
    zeta_0_med, zeta_0_ot, zeta_0_tmatch,
    zeta_0_skh, zeta_0_sot_12, zeta_0_sot_21
  ) |> 
  pivot_longer(
    cols = c(zeta_0_med, zeta_0_ot, zeta_0_tmatch,
    zeta_0_skh, zeta_0_sot_12, zeta_0_sot_21), 
    names_to = "type", values_to = "val"
  ) |> 
  mutate(
    type = factor(
      type,
      levels = c(
        "zeta_0_med", "zeta_0_ot", "zeta_0_tmatch",
        "zeta_0_skh", "zeta_0_sot_12", "zeta_0_sot_21"
      ),
      labels = c("CM", "OT", "OT-M", "SKH", "ST(1)", "ST(2)")
    ),
    dist_to_theo_val = 3 - val
  )
ggplot(
  data = data_plot,
  mapping = aes(x = factor(prop_0), y = dist_to_theo_val)
) +
  geom_violin(
    mapping = aes(fill = type)
  ) +
  geom_hline(yintercept = 0, colour = "darkred", linetype = "dashed") +
  theme_paper() +
  facet_wrap(~type, scales = "free_x", ncol = 2) +
  scale_fill_manual(
    NULL,
    values = c(
      "CM" = "#56B4E9",
      "OT" = colour_methods[["OT"]], 
      "OT-M" = colour_methods[["OT-M"]], 
      "SKH" = colour_methods[["skh"]], 
      "ST(1)" =  colour_methods[["seq_1"]],
      "ST(2)" =  colour_methods[["seq_2"]]
    ),
    guide = "none"
  ) +
  theme(legend.position = "bottom") +
  labs(
    x = "Proportion of 0",
    y = "Distance to theoretical natural direct effect",
  ) +
  scale_x_discrete(
    labels = ifelse(
      (unique(data_plot$prop_0)*100) %% 10 == 0, 
      yes = unique(data_plot$prop_0), no = "")
  )
```

### Natural Direct Effect ($\zeta(1)$)

```{r}
#| fig-width: 8
#| fig-height: 6
#| code-fold: true
#| code-summary: Codes to create the Figure.
data_plot <- res_sim_prop |> 
  dplyr::select(
    n0, n1, seed, a, mu0, mu1, prop_0,
    zeta_1_med, zeta_1_ot, zeta_1_tmatch,
    zeta_1_skh, zeta_1_sot_12, zeta_1_sot_21
  ) |> 
  pivot_longer(
    cols = c(
    zeta_1_med, zeta_1_ot, zeta_1_tmatch,
    zeta_1_skh, zeta_1_sot_12, zeta_1_sot_21), 
    names_to = "type", values_to = "val"
  ) |> 
  mutate(
    type = factor(
      type,
      levels = c(
        "zeta_1_med", "zeta_1_ot", "zeta_1_tmatch",
        "zeta_1_skh", "zeta_1_sot_12", "zeta_1_sot_21"
      ),
      labels = c("CM", "OT", "OT-M", "SKH", "ST(1)", "ST(2)")
    ),
    dist_to_theo_val = 3 - val
  )
ggplot(
  data = data_plot,
  mapping = aes(x = factor(prop_0), y = dist_to_theo_val)
) +
  geom_violin(
    mapping = aes(fill = type)
  ) +
  geom_hline(yintercept = 0, colour = "darkred", linetype = "dashed") +
  theme_paper() +
  facet_wrap(~type, scales = "free_x", ncol = 2) +
  scale_fill_manual(
    NULL,
    values = c(
      "CM" = "#56B4E9",
      "OT" = colour_methods[["OT"]], 
      "OT-M" = colour_methods[["OT-M"]], 
      "SKH" = colour_methods[["skh"]], 
      "ST(1)" =  colour_methods[["seq_1"]],
      "ST(2)" =  colour_methods[["seq_2"]]
    ),
    guide = "none"
  ) +
  theme(legend.position = "bottom") +
  labs(
    x = "Proportion of 0",
    y = "Distance to theoretical natural direct effect",
  ) +
  scale_x_discrete(
    labels = ifelse(
      (unique(data_plot$prop_0)*100) %% 10 == 0, 
      yes = unique(data_plot$prop_0), no = "")
  )
```
:::


