# Simulated Data


:::{.callout-note}

## Objectives

In this page, xxx

:::

```{r package-settings}
#| warning: false
#| message: false
library(tidyverse)
# remotes::install_github(
#   repo = "fer-agathe/sequential_transport", subdir = "seqtransfairness"
# )
library(seqtransfairness)
# remotes::install_github(repo = "fer-agathe/transport-simplex")
library(transportsimplex)
library(randomForest)
library(grf)
library(cluster)

# Also required:
# install.packages(mlr3fairness)
```

```{r}
#| echo: false
#| eval: true
#| message: false
#| warning: false
#| file: _myfunctions.R
```

$$
\definecolor{wongBlack}{RGB}{0,0,0}
\definecolor{wongGold}{RGB}{230, 159, 0}
\definecolor{wongLightBlue}{RGB}{86, 180, 233}
\definecolor{wongGreen}{RGB}{0, 158, 115}
\definecolor{wongYellow}{RGB}{240, 228, 66}
\definecolor{wongBlue}{RGB}{0, 114, 178}
\definecolor{wongOrange}{RGB}{213, 94, 0}
\definecolor{wongPurple}{RGB}{204, 121, 167}
\definecolor{colA}{RGB}{255, 221, 85}
\definecolor{colB}{RGB}{148, 78, 223}
\definecolor{colC}{RGB}{63, 179, 178}
\definecolor{colGpeZero}{RGB}{127, 23, 14}
\definecolor{colGpeUn}{RGB}{27, 149, 224}
$$

```{r graphs-settings}
#| code-fold: true
#| code-summary: Codes for graphical parameters.
library(extrafont, quietly = TRUE)
font_family <- "CMU Serif"

path <- "./figs/"
if (!dir.exists(path)) dir.create(path)
```

We load the functions that will allow us to build the counterfactuals (see [Chapter -@sec-functions]), and some graphical themes for the plots (see [Chapter -@sec-utils):
```{r source-functions}
source("../scripts/functions.R")
source("../scripts/utils.R")
```

## Data Generating Process {#sec-dgp}

We simulate a dataset comprising a binary treatment indicator $A \in \{0,1\}$, a binary outcome $Y \in \{0,1\}$, and three covariates: two continuous variables $X_1, X_2 \in \mathbb{R}$ and one categorical variable $X_3 \in \{\text{A}, \text{B}, \text{C}\}$. For individuals with $A = 0$, the vector $(X_1, X_2)$ is drawn from a bivariate normal distribution with mean vector $\mu_0 = (-1, -1)$ and covariance matrix $\Sigma_0 = 1.2^2 \begin{bmatrix} 1 & 0.5 \\ 0.5 & 1 \end{bmatrix}$. For those with $A = 1$, the distribution shifts to mean $\mu_1 = (1.5, 1.5)$ and covariance $\Sigma_1 = 0.9^2 \begin{bmatrix} 1 & -0.4 \\ -0.4 & 1 \end{bmatrix}$. This leads to distinct location and dependence structures across treatment groups.

The categorical variable $X_3$ is generated conditionally on $X_1, X_2$, and $A$ via a multinomial logistic model. Letting $p_{\text{A}}, p_{\text{B}}, p_{\text{C}}$ denote the unnormalized logit scores for each level of $X_3$, we set:

$$
\begin{aligned}
p_{\text{A}} &= 0.5 + 0.3 X_1 - 0.4 X_2 + 0.2 A, \\
p_{\text{B}} &= -0.3 + 0.5 X_2 - 0.2 X_1 - 0.1 A, \\
p_{\text{C}} &= 0,
\end{aligned}
$$

with the associated probabilities obtained via softmax normalization:

$$
P(X_3 = k) = \frac{\exp(p_k)}{\exp(p_{\text{A}}) + \exp(p_{\text{B}}) + \exp(p_{\text{C}})}, \quad \text{for } k \in \{\text{A}, \text{B}, \text{C}\}.
$$

The binary outcome $Y$ is modeled using a logistic regression, with functional forms differing across treatment groups. For $A = 0$, the log-odds is defined as:

$$
\eta_0 = -0.2 + 0.6 X_1 - 0.6 X_2 + \gamma(X_3),
$$

and for $A = 1$:

$$
\eta_1 = 0.1 - 0.2 X_1 + 0.8 X_2 + \gamma(X_3),
$$

where the contribution of $X_3$ is encoded as:

$$
\gamma(X_3) =
\begin{cases}
0.2 & \text{if } X_3 = \text{B}, \\
-0.3 & \text{if } X_3 = \text{C}, \\
0 & \text{if } X_3 = \text{A},
\end{cases}
\quad \text{(for } A = 0\text{)},
$$

and similarly, for $A = 1$:

$$
\gamma(X_3) =
\begin{cases}
-0.2 & \text{if } X_3 = \text{B}, \\
-0.1 & \text{if } X_3 = \text{C}, \\
0 & \text{if } X_3 = \text{A}.
\end{cases}
$$

The outcome $Y$ is then drawn from a Bernoulli distribution with success probability $P[Y = 1] = \mathrm{logit}^{-1}(\eta_A)$.

For each observation, we additionally simulate a counterfactual covariate vector and outcome under the opposite treatment status. This includes drawing $(X_1^{\text{cf}}, X_2^{\text{cf}})$ from the treatment-specific bivariate normal distribution of the opposite group, computing the corresponding $X_3^{\text{cf}}$ using the same multinomial model (with $A$ flipped), and evaluating $Y^{\text{cf}}$ via the appropriate counterfactual logit model.

We draw $n_0=400$ observations in group 0 and $n_1=200$ observations in group 1. We generate a function, `gen_data()`{.R} to generate data from this data generating process.

```{r define-gen_data}
#| code-fold: true
#| code-summary: The `gen_data()`{.R} function.
gen_data <- function(seed) {
  set.seed(seed)
  n_0 <- 400
  n_1 <- 200
  
  # X1 and X2 in both groups from sensitive-specific multivariate normal 
  # distributions
  M_0 <- c(-1, -1)
  S_0 <- matrix(c(1, .5, .5, 1) * 1.2^2, 2, 2)
  M_1 <- c(1.5, 1.5)
  S_1 <- matrix(c(1, -.4, -.4, 1) * 0.9^2, 2, 2)
  X_0 <- MASS::mvrnorm(n = n_0, mu = M_0, Sigma = S_0)
  X_1 <- MASS::mvrnorm(n = n_1, mu = M_1, Sigma = S_1)
  
  # Counterfactuals
  X_0_cf <- MASS::mvrnorm(n = n_0, mu = M_1, Sigma = S_1)
  X_1_cf <- MASS::mvrnorm(n = n_1, mu = M_0, Sigma = S_0)
  
  # X3: categorical, depends on S, X1, X3
  scores <- function(x1, x2, a) {
    p_A <- 0.5 + 0.3 * x1 - 0.4 * x2 + 0.2 * a
    p_B <- -0.3 + 0.5 * x2 - 0.2*x1 - 0.1 * a
    p_C <- 0
    exps <- exp(cbind(p_A, p_B, p_C))
    prob <- exps / rowSums(exps)
    prob
  }
  
  prob_X3_0 <- scores(x1 = X_0[, 1], x2 = X_0[, 2], a = 0)
  prob_X3_1 <- scores(x1 = X_1[, 1], x2 = X_1[, 2], a = 1)
  X3_0 <- apply(prob_X3_0, 1, function(p) sample(c("A", "B", "C"), 1, prob = p))
  X3_1 <- apply(prob_X3_1, 1, function(p) sample(c("A", "B", "C"), 1, prob = p))
  
  # Counterfactuals
  prob_X3_0_cf <- scores(x1 = X_0_cf[, 1], x2 = X_0_cf[, 2], a = 1)
  prob_X3_1_cf <- scores(x1 = X_1_cf[, 1], x2 = X_1_cf[, 2], a = 0)
  X3_0_cf <- apply(prob_X3_0_cf, 1, function(p) sample(c("A", "B", "C"), 1, prob = p))
  X3_1_cf <- apply(prob_X3_1_cf, 1, function(p) sample(c("A", "B", "C"), 1, prob = p))
  
  
  # Predictor for Y:
  eta_0 <- -0.2 + 0.6 * X_0[, 1] - 0.6 * X_0[, 2] + 
    ifelse(X3_0 == "B", 0.2, ifelse(X3_0 == "C", -0.3, 0))
  eta_1 <- 0.1 - 0.2 * X_1[, 1] + 0.8 * X_1[, 2] + 
    ifelse(X3_1 == "B", -0.2, ifelse(X3_1 == "C", -0.1, 0))
  
  p_0 <- exp(eta_0) / (1 + exp(eta_0))
  p_1 <- exp(eta_1) / (1 + exp(eta_1))
  
  # Predictor for Y, counterfactuals
  eta_0_cf <- 0.1 - 0.2 * X_0_cf[, 1] + 0.8 * X_0_cf[, 2] + 
    ifelse(X3_0_cf == "B", -0.2, ifelse(X3_0_cf == "C", -0.1, 0))
  
  eta_1_cf <- -0.2 + 0.6 * X_1_cf[, 1] - 0.6 * X_1_cf[, 2] + 
    ifelse(X3_1_cf == "B", 0.2, ifelse(X3_1_cf == "C", -0.3, 0))
  
  p_0_cf <- exp(eta_0_cf) / (1 + exp(eta_0_cf))
  p_1_cf <- exp(eta_1_cf) / (1 + exp(eta_1_cf))
  
  
  Y_0 <- rbinom(n_0, size = 1, prob = p_0)
  Y_1 <- rbinom(n_1, size = 1, prob = p_1)
  
  Y_0_cf <- rbinom(n_0, size = 1, prob = p_0_cf)
  Y_1_cf <- rbinom(n_1, size = 1, prob = p_1_cf)
  
  # Dataset with individuals in group 0 only
  data_0 <- tibble(
    A = 0, 
    X1 = X_0[, 1], X2 = X_0[, 2], X3 = X3_0, Y = Y_0,
    X1_cf = X_0_cf[, 1], X2_cf = X_0_cf[, 2], X3_cf = X3_0_cf, Y_cf = Y_0_cf,
    eta = eta_0, p = p_0,
    eta_cf = eta_0_cf, p_cf = p_0_cf
  ) |> 
    bind_cols(as_tibble(prob_X3_0) |> rename_with(~ str_c("X3_", .))) |> 
    bind_cols(as_tibble(prob_X3_0_cf) |> rename_with(~ str_c("X3_cf_", .)))
  # Dataset with individuals in group 1 only
  data_1 <- tibble(
    A = 1, 
    X1 = X_1[, 1], X2 = X_1[, 2], X3 = X3_1, Y = Y_1,
    X1_cf = X_1_cf[, 1], X2_cf = X_1_cf[, 2], X3_cf = X3_1_cf, Y_cf = Y_1_cf,
    eta = eta_1,  p = p_1,
    eta_cf = eta_1_cf, p_cf = p_1_cf
  ) |> 
    bind_cols(as_tibble(prob_X3_1) |> rename_with(~ str_c("X3_", .))) |> 
    bind_cols(as_tibble(prob_X3_1_cf) |> rename_with(~ str_c("X3_cf_", .)))
  # # Combine final dataset
  data_all <- rbind(data_0, data_1)
  
  data_all
}
```

Let us generate a dataset:
```{r define-tb <- gen_data(2)}
tb <- gen_data(2) |> 
  mutate(across(where(is.character), ~as.factor(.x)))
```


```{r}
#| code-fold: true
#| code-summary: Codes to create the Figure
#| fig-cap: !expr glue::glue("Distribution of the true probability of the outcome across groups for the <span style='color:{c0};'>untreated</span> and the <span style='color:{c1};'>treated</span>, for observed values (left) and unobserved values (right).", c0 = colours[["0"]], c1 = colours[["1"]])

#| label: fig-dist-true-prob
#| message: false
#| warning: false
ggplot(
  data = tb |> mutate(A = factor(A)) |> select(A, p, p_cf) |> 
    pivot_longer(cols = c(p, p_cf), names_to = "type", values_to = "p") |> 
    mutate(
      type = factor(type, levels = c("p", "p_cf"), labels = c("Obs.", "Counterfactual")
      )
    ),
  mapping = aes(x = p)
) +
  geom_histogram(
    mapping = aes(fill = A), alpha = .5, colour = "black",
    position = "identity", bins = 30
  ) +
  facet_wrap(~type) +
  scale_fill_manual(values = c("0" = colours[["0"]], "1" = colours[["1"]])) +
  theme_paper()
```

## Counterfactuals

We assume a structural model as shown in @fig-dag.

```{r}
#| fig-cap: Asumed Causal Structure
#| label: fig-dag
variables <- c("A", "X1", "X2", "X3", "Y")

adj <- matrix(
  # A  X1 X2 X3 Y
  c(0, 1, 1, 1, 1,# A
    0, 0, 1, 1, 1,# X1
    0, 0, 0, 1, 1,# X2
    0, 0, 0, 0, 1,# X3
    0, 0, 0, 0, 0  # Y
  ),
  ncol = length(variables),
  dimnames = rep(list(variables), 2),
  byrow = TRUE
)

causal_graph <- fairadapt::graphModel(adj)
plot(causal_graph)
```



Let us follow this DAG and build the counterfactuals of `r colorize("untreated", colours[["0"]])`: we thus transport individuals from $A=0$ to $A=1$. Let us set a seed for reproducibility.

```{r}
seed <- 1234
set.seed(seed)
```

We call the `seq_trans()`{.R} function (see [Chapter -@sec-functions]) function to build the counterfactuals of untreated individuals. The estimations are done using parallel computation.

```{r}
A_name <- "A" # treatment name
Y_name <- "Y" # outcome name
A_untreated <- 0
```



```{r define-sequential_transport, eval=FALSE}
# The estimation takes about 16 secondes to run.
# We do not run it here, it was previously estimated.
library(pbapply)
library(parallel)
ncl <- detectCores()-1
(cl <- makeCluster(ncl))

clusterEvalQ(cl, {
  library(transportsimplex)
  source("../scripts/functions.R")
}) |>
  invisible()

sequential_transport <- seq_trans(
  data = tb, 
  adj = adj, 
  s = A_name, 
  S_0 = 0, # source: untreated
  y = Y_name, 
  num_neighbors = 50, 
  num_neighbors_q = NULL,
  silent = FALSE,
  method = "shortsimplex",
  cl = cl
)

save(sequential_transport, file = "../output/res_simul-seq-t.rda")

stopCluster(cl)
```

Let us load the results of the estimation:
```{r load-sequential_transport}
load("../output/res_simul-seq-t.rda")
```

## Measuring the Causal Effect

```{r define-tb_estim}
tb_estim <- tb |> select(Y, A, X1, X2, X3)
A_name <- "A"
A_untreated <- 0
Y_name <- "Y"
```


### With Causal Mediation Analysis

Let us use the `multimed()`{.R} function from {mediation} to estimate:

- $\bar{\delta}(0)$: the average causal mediation effect for $a=0$,
- $\bar{\zeta}(1)$: the average direct effect for $a=1$,
- $\bar{\tau} = \bar{\delta}(0) + \bar{\zeta}(1)$: the total causal effect.

```{r estim-causal-effect-mediation}
#| message: false
#| warning: false
# library(mediation) # we do not load it
#  otherwise it masks a lot of useful functions
med_mod <- mediation::multimed(
  outcome = "Y", 
  med.main = "X1", 
  med.alt = c("X2", "X3"),
  treat = "A", 
  data = tb_estim
)

delta_0_med <- mean((med_mod$d0.lb + med_mod$d0.ub) / 2)
zeta_1_med <- mean((med_mod$z1.lb + med_mod$z1.ub) / 2)
tot_effect_med <- delta_0_med + zeta_1_med
```

The estimated values:

```{r show-estim-mediation}
cbind(delta_0 = delta_0_med, zeta_1 = zeta_1_med, tot_effect = tot_effect_med)
```

### With Sequential Optimal Transport

```{r library-randomForest}
#| message: false
#| warning: false
library(randomForest)
```

We use a random forest to estimate the outcome model (see `causal_effects_cf()`{.R} in [Chapter -@sec-functions]).

```{r}
#| warning: false
#| message: false
tb_untreated <- tb_estim |> filter(!!sym(A_name) == !!A_untreated)
tb_treated <- tb_estim |> filter(!!sym(A_name) != !!A_untreated)

causal_effects_sot <- causal_effects_cf(
  data_untreated = tb_untreated, 
  data_treated = tb_treated,
  data_cf = as_tibble(sequential_transport$transported), 
  Y_name = Y_name, 
  A_name = A_name, 
  A_untreated = A_untreated
)

cbind(
  delta_0 = causal_effects_sot$delta_0,
  zeta_1 = causal_effects_sot$zeta_1, 
  tot_effect = causal_effects_sot$tot_effect
)
```

## Monte-Carlo Experiment

We run Monte-Carlo simulations to reproduce the previous steps. In each of the 200 iteration, we draw some data according to the DGP presented in @sec-dgp. Then, we use the `seq_trans()`{.R} function (see [Chapter -@sec-functions]) to perform sequential conditional transport to transport individuals from the `r colorize("untreated group", colours[["0"]])` ($A=0$) to the `r colorize("treated group", colours[["1"]])` ($A=1$).

We set the seeds for each replication and we define placeholders.
```{r define-res_ATT}
seeds <- 1:200
res_simul_transp <- vector(mode = "list", length = length(seeds))
res_simul_effects <- vector(mode = "list", length = length(seeds))
```

```{r, eval=FALSE}
# This chunk is not evaluated.
# Each of the 200 replications takes about 16 seconds to run
library(pbapply)
library(parallel)
ncl <- detectCores()-1
(cl <- makeCluster(ncl))

clusterEvalQ(cl, {
  library(transportsimplex)
  source("../scripts/functions.R")
}) |>
  invisible()

for (i in 1:length(seeds)) {
  cat(paste0("Simulation ", i, "/", length(seeds), "\n"))
  seed <- seeds[i]
  tb_all <- gen_data(seed)
  tb <- tb_all |> select(A, X1, X2, X3, Y) |> 
    mutate(across(where(is.character), ~as.factor(.x)))
  
  A_name <- "A"
  A_untreated <- 0
  Y_name <- "Y"
  
  sequential_transport <- seq_trans(
    data = tb, 
    adj = adj, 
    s = A_name, 
    S_0 = 0, # source: untreated
    y = Y_name, 
    num_neighbors = 50, 
    num_neighbors_q = NULL,
    silent = FALSE,
    cl = cl
  )
  res_simul_transp[[i]] <- sequential_transport
  
  tb_untreated <- tb |> filter(!!sym(A_name) == !!A_untreated)
  tb_treated <- tb |> filter(!!sym(A_name) != !!A_untreated)
  
  n_untreated <- nrow(tb_untreated)
  n_treated <- nrow(tb_treated)
  
  ## Measuring Causal Effect----
  
  # With Causal Mediation Analysis
  med_mod <- mediation::multimed(
    outcome = "Y", 
    med.main = "X1", 
    med.alt = c("X2", "X3"),
    treat = "A", 
    data = tb |> mutate(X3 = as.numeric(X3))
  )
  
  delta_0_med <- mean((med_mod$d0.lb + med_mod$d0.ub) / 2)
  zeta_1_med <- mean((med_mod$z1.lb + med_mod$z1.ub) / 2)
  tot_effect_med <- delta_0_med + zeta_1_med
 
  # With Counterfactual Values
  causal_effects_sot <- causal_effects_cf(
    data_untreated = tb_untreated, 
    data_treated = tb_treated,
    data_cf = as_tibble(sequential_transport$transported), 
    Y_name = Y_name, 
    A_name = A_name, 
    A_untreated = A_untreated
  )
  
  res_simul_effects[[i]] <- tibble(
    seed = seed,
    delta_0_med = delta_0_med, 
    zeta_1_med = zeta_1_med, 
    tot_effect_med = tot_effect_med,
    delta_0_sot = causal_effects_sot$delta_0,
    zeta_1_sot = causal_effects_sot$zeta_1, 
    tot_effect_sot = causal_effects_sot$tot_effect
    )
}


save(res_simul_transp, res_simul_effects, file = "../output/res_simul.rda")

stopCluster(cl)
```



We load previously run simulations:
```{r load-res_simul}
load("../output/res_simul.rda")
```

We can have a look at the `r colorize("transported values", colours[["B"]])` for variable $X_3$ (from `r colorize("group 0", colours[["0"]])` to `r colorize("group 1", colours[["1"]])`) of the first run, on a ternary plot (@fig-ternary-simul-1).

```{r}
#| code-fold: true
#| code-summary: Codes to create the Figure.
#| fig-cap: !expr glue::glue("$X_3$ values for individuals from <span style='color:{c0};'>group 0</span>, those from <span style='color:{c1};'>group 1</span>, and those <span style='color:{c2};'>transported</span> from group 0 to group 1 using sequential transport.", c0 = colours[["0"]], c1 = colours[["1"]], c2 = colours[["B"]])
#| label: fig-ternary-simul-1
#| warning: false
#| message: false
library(ggtern)
i <- 1
ggtern(
  data = gen_data(i) |> select(A, X3_p_A,X3_p_B, X3_p_C) |> 
    mutate(A = as.character(A)) |> 
    bind_rows(
      as_tibble(res_simul_transp[[i]]$transported_prob$X3) |> 
        rename_with(.fn = ~str_c("X3_p_", .)) |> 
        mutate(A = "1 to 0")
    ) |> 
    mutate(A = factor(A, levels = c("0", "1", "1 to 0"))),
  mapping = aes(x = X3_p_A, y = X3_p_B, z = X3_p_C)
) +
  geom_point(
    mapping = aes(colour = A), size = .5, alpha = .2
  ) +
  labs(x = "A", y = "B", z = "C") +
  scale_colour_manual(
    values = c("0" = colours[["0"]], "1" = colours[["1"]], "1 to 0" = colours[["B"]])
  ) +
  theme_light(base_size = font_size, base_family = font_family) +
  theme_ggtern_paper() +
  theme(
    legend.title = element_text(size = .8 * font_size),
    legend.text = element_text(size = .8 * font_size),
    tern.axis.vshift = .08,
    tern.axis.arrow.sep = .16,
  ) +
  theme_hidetitles() +
  guides(
    colour = guide_legend(
      override.aes = list(
        size = 1.5,
        alpha = 1
      )
    )
  )
```

Then, we can look at the measures of causal effects.
```{r define-ATT}
causal_effects <- list_rbind(res_simul_effects)
```


```{r}
#| code-fold: true
#| code-summary: Codes to create the Figure.
#| fig-cap: !expr glue::glue("Causal effects, {n} replications.", n = length(seeds))
#| label: fig-simul-mc-causal-effects
data_plot <- causal_effects |> 
  pivot_longer(
    cols = -seed, 
    names_to = "name", values_to = "tau"
  ) |> 
  mutate(
    type = case_when(
      str_detect(name, "^delta") ~ "delta",
      str_detect(name, "^zeta") ~ "zeta",
      str_detect(name, "^tot_effect") ~ "tot_effect",
      TRUE ~ NA_character_
    ),
    type = factor(
      type, 
      levels = c("delta", "zeta", "tot_effect"),
      labels = c(
        "$\\bar{\\delta}(0)$",
        "$\\bar{\\zeta}(1)$",
        "$\\bar{\\tau}$"
      )),
    Method = case_when(
      str_detect(name, "_med$") ~ "causal_med",
      str_detect(name, "_sot$") ~ "seq_ot",
      TRUE ~ NA_character_
    ),
    Method = factor(
      Method,
      levels = c(
        "causal_med", "seq_ot"
      ),
      labels = c("Causal Med.", "Seq. OT")
    )
  )
ggplot(
  data = data_plot,
  mapping = aes(x = tau, y = Method)
) +
  geom_violin(
    mapping = aes(fill = Method),
    draw_quantiles = c(0.25, 0.5, 0.75)
  ) +
  geom_hline(yintercept = 0, colour = "darkred", linetype = "dashed") +
  theme_paper() +
  facet_wrap(
    ~type, nrow = 1,
    labeller = as_labeller(latex2exp::TeX, default = label_parsed)
  ) +
  scale_fill_manual(
    NULL,
    values = c(
      "Causal Med." = "#E69F00",
      "Seq. OT" = "#009E73"
    )
  ) +
  labs(y = NULL, x = latex2exp::TeX("$\\tau$")) +
  theme(legend.position = "bottom") # axis.text.y = element_blank()
```


