# Adult


:::{.callout-note}

## Objectives

In this page, xxx

:::

```{r package-settings}
#| warning: false
#| message: false
library(tidyverse)
# remotes::install_github(
#   repo = "fer-agathe/sequential_transport", subdir = "seqtransfairness"
# )
library(seqtransfairness)
# remotes::install_github(repo = "fer-agathe/transport-simplex")
library(transportsimplex)
library(randomForest)
library(grf)
library(cluster)
```

```{r}
#| echo: false
#| eval: true
#| message: false
#| warning: false
#| file: _myfunctions.R
```

$$
\definecolor{wongBlack}{RGB}{0,0,0}
\definecolor{wongGold}{RGB}{230, 159, 0}
\definecolor{wongLightBlue}{RGB}{86, 180, 233}
\definecolor{wongGreen}{RGB}{0, 158, 115}
\definecolor{wongYellow}{RGB}{240, 228, 66}
\definecolor{wongBlue}{RGB}{0, 114, 178}
\definecolor{wongOrange}{RGB}{213, 94, 0}
\definecolor{wongPurple}{RGB}{204, 121, 167}
\definecolor{colA}{RGB}{255, 221, 85}
\definecolor{colB}{RGB}{148, 78, 223}
\definecolor{colC}{RGB}{63, 179, 178}
\definecolor{colGpeZero}{RGB}{127, 23, 14}
\definecolor{colGpeUn}{RGB}{27, 149, 224}
$$

```{r graphs-settings}
#| code-fold: true
#| code-summary: Codes for graphical parameters.
library(extrafont, quietly = TRUE)
font_family <- "CMU Serif"


path <- "./figs/"
if (!dir.exists(path)) dir.create(path)
```

We load the functions that will allow us to build the counterfactuals (see @sec-functions):
```{r source-functions}
source("../scripts/functions.R")
```


## Data

We load the Adult dataset that is available in the {fairadapt} package.

```{r load-adult-data}
vars <- c(
  "sex", "age", "native_country", "marital_status", "education_num",
  "workclass", "hours_per_week", "occupation", "income"
)
s <- "sex"
y <- "income"

# reading in the UCI Adult data from {fairadapt}
adult <- readRDS(
  system.file("extdata", "uci_adult.rds", package = "fairadapt")
) |>
  as_tibble() |> 
  select(!!vars) |> 
  mutate(
   occupation = fct_lump_prop(occupation, prop = 0.02)
  )
```

The outcome variable is binary here: whether the defendant is rearrested at any time. The "treatment" $A$ will be the sensitive attribute, `race`. We will consider a binary version of the race: `Caucasian` (whites, $A=1$) and `African-American` (Blacks, $A=0$). The idea is to build counterfactuals for Black people to ask questions such as "had this Black individual been white, what whould the prediction of an algorithm modeling recidivism be?".

To train the predictive model of recidivism, we will use the following covariates: the age, the prior criminal records of defendants, and the charge degree (felony or misdemeanor).

```{r define-tb}
tb <- adult
```

```{r show-summary-tb}
dim(tb)
summary(tb)
```

We assume the DAG shown in @fig-dag-compas.

```{r}
#| fig-cap: Assumed structural model for the probability of recidivism.
#| label: fig-dag-compas
adj_mat <- c(
  0, 0, 0, 1, 1, 1, 1, 1, 1, # sex
  0, 0, 0, 1, 1, 1, 1, 1, 1, # age
  0, 0, 0, 1, 1, 1, 1, 1, 1, # native_country
  0, 0, 0, 0, 1, 1, 1, 1, 1, # marital_status
  0, 0, 0, 0, 0, 1, 1, 1, 1, # education_num
  0, 0, 0, 0, 0, 0, 0, 0, 1, # workclass
  0, 0, 0, 0, 0, 0, 0, 0, 1, # hours_per_week
  0, 0, 0, 0, 0, 0, 0, 0, 1, # occupation
  0, 0, 0, 0, 0, 0, 0, 0, 0  # income
) |> matrix(
  nrow = length(vars), ncol = length(vars),
  dimnames = list(vars, vars), byrow = TRUE
)

causal_graph <- fairadapt::graphModel(adj_mat)
plot(causal_graph)
```
## Model Fitting

## Counterfactuals

Let us follow the DAG from @fig-dag-compas and build the counterfactuals of Black individuals: we thus transport individuals from $A=1$ to $A=0$. Let us set a seed for reproducibility.

```{r}
seed <- 1234
set.seed(seed)
```

```{r}
A_name <- "sex" # treatment name
Y_name <- "income" # outcome name
A_untreated <- "Female"
A <- tb[[A_name]]
ind_untreated <- which(A == A_untreated)
tb_untreated <- tb[ind_untreated, ]
tb_treated <- tb[-ind_untreated, ]
```

Let us follow the DAG from @fig-dag-compas and build the counterfactuals of Black individuals: we thus transport individuals from $A=0$ to $A=1$, using the predictions on the test set. 

### Multivariate Optimal Transport

```{r}
tb_untreated_wo_A <- tb_untreated[ , !(names(tb_untreated) %in% A_name)]
tb_treated_wo_A <- tb_treated[ , !(names(tb_treated) %in% A_name)]
n0 <- nrow(tb_untreated_wo_A)
n1 <- nrow(tb_treated_wo_A)
y0 <- tb_untreated_wo_A[[Y_name]]
y1 <- tb_treated_wo_A[[Y_name]]
X0 <- tb_untreated_wo_A[ , !(names(tb_untreated_wo_A) %in% Y_name)]
X1 <- tb_treated_wo_A[ , !(names(tb_treated_wo_A) %in% Y_name)]
```

To apply Optimal Transport on the COMPAS dataset, we first need to one-hot the categorical variables.

```{r}
num_cols <- names(X0)[sapply(X0, is.numeric)]
cat_cols <- names(X0)[sapply(X0, function(col) is.factor(col) || is.character(col))]
X0_num <- X0[ , num_cols]
X1_num <- X1[ , num_cols]
X0_cat <- X0[ , cat_cols]
X1_cat <- X1[ , cat_cols]

cat_counts <- sapply(X0[ , cat_cols], function(col) length(unique(col)))
```

Categorical variables are one-hot encoded:
```{r}
library(caret)
X0_cat_encoded <- list()
X1_cat_encoded <- list()
for (col in cat_cols) {
  # One-hot encoding with dummyVars
  formula <- as.formula(paste("~", col))
  dummies <- dummyVars(formula, data = X0_cat)
  
  # Dummy variable
  dummy_0 <- predict(dummies, newdata = X0_cat) %>% as.data.frame()
  dummy_1 <- predict(dummies, newdata = X1_cat) %>% as.data.frame()
  
  # Scaling
  dummy_0_scaled <- scale(dummy_0)
  dummy_1_scaled <- scale(dummy_1)

  dummy_0_df <- as.data.frame(dummy_0_scaled)
  dummy_1_df <- as.data.frame(dummy_1_scaled)
  
  # Aling categories in both treated/untreated groups
  all_cols <- union(colnames(dummy_0_df), colnames(dummy_1_df))
  dummy_0_df <- dummy_0_df %>% mutate(across(.fns = identity)) %>% select(all_of(all_cols)) %>% replace(is.na(.), 0)
  dummy_1_df <- dummy_1_df %>% mutate(across(.fns = identity)) %>% select(all_of(all_cols)) %>% replace(is.na(.), 0)
  
  # Sauvegarde dans les listes
  X0_cat_encoded[[col]] <- dummy_0_df
  X1_cat_encoded[[col]] <- dummy_1_df
}
```
We calculate Euclidean distance for numerical variables.

```{r}
library(proxy)
num_dist <- dist(x = X0_num, y = X1_num, method = "Euclidean")
num_dist <- as.matrix(num_dist)
```

For categorical variables, we use the Hamming distance.
```{r}
cat_dists <- list()
for (col in cat_cols) {
  mat_0 <- as.matrix(X0_cat_encoded[[col]])
  mat_1 <- as.matrix(X1_cat_encoded[[col]])
  dist_mat <- dist(x = mat_0, y = mat_1, method = "Euclidean")
  cat_dists[[col]] <- as.matrix(dist_mat)
}
```

Then we need to combine the two distance matrices. We use weights equal to the proportion of numerical variables and the proportion of categorical variables, respectively for distances based on numerical and categorical variables.

```{r}
combined_cost <- num_dist
for (i in seq_along(cat_dists)) {
  combined_cost <- combined_cost + cat_dists[[i]]
}
```

Then, we can compute the transport map:
```{r}
# Uniform weights (equal mass)
w0 <- rep(1 / n0, n0)
w1 <- rep(1 / n1, n1)
# Compute transport plan
transport_res <- transport::transport(
  a = w0,
  b = w1,
  costm = combined_cost,
  method = "shortsimplex"
)

transport_plan <- matrix(0, nrow = n0, ncol = n1)
for(i in seq_len(nrow(transport_res))) {
  transport_plan[transport_res$from[i], transport_res$to[i]] <- transport_res$mass[i]
}
```

We first transport the numerical variables.
```{r}
num_transported <- n0 * (transport_plan %*% as.matrix(X1_num))
```

Then, we transport the categorical variables with label reconstruction (not perfect here).
```{r}
cat_transported <- list()
for (col in cat_cols) {
  cat_probs <- transport_plan %*% as.matrix(X1_cat_encoded[[col]])
  cat_encoded_columns <- colnames(X1_cat_encoded[[col]])
  # For each obs., we take the index with the maximum value (approx. proba)
  max_indices <- apply(cat_probs, 1, which.max)
  cat_transported[[col]] <- sapply(max_indices, function(x) sub(paste0("^", col, "_"), "", cat_encoded_columns[x]))
}

```

### Optimal Transport



We call the  `seq_trans()`{.R} function (see [Chapter -@sec-functions]) function to build the counterfactuals of Black individuals. The estimations are done using parallel computation.

```{r define-sequential_transport}
library(pbapply)
library(parallel)
ncl <- detectCores()-1
(cl <- makeCluster(ncl))

clusterEvalQ(cl, {
  library(transportsimplex)
}) |>
  invisible()


A_name <- "race" # treatment name
Y_name <- "is_recid" # outcome name

sequential_transport <- seq_trans(
  data = tb, 
  adj = adj, 
  s = A_name, 
  S_0 = 1, # source: treated
  y = Y_name, 
  num_neighbors = 50, 
  num_neighbors_q = NULL,
  silent = FALSE,
  cl = cl
)

stopCluster(cl)
```
## Measuring the Causal Effect

### ATT with the Conditional Optimal Transport Approach

Recall that the average treatment on the treated writes
$$
\text{ATT} = \mathbb{E}\bigl[Y(1) - Y(0) \mid A=1\bigr]
$$

For a treated unit $i$ (Black individual), $Y_i(1)$ corresponds to the observed value and $Y_i(0)$ to its counterfactual, i.e. $Y_i(0)\mid A=1 = x_{1,i}^\star$.

$$
\widehat{\text{ATT}}^{\text{COT}} = \frac{1}{n_1} \sum_{i:A_i=1}\bigl[ Y_i -  \hat{\mu}_0(x_{1,i}^\star)\bigr],
$$ {#eq-att-cot}
where $\hat{\mu}_0()$ is the predictive outcome model trained on the untreated (white individuals), i.e., an estimation of $\mu_0(\boldsymbol{X}_i) = \mathbb{E}[Y_i \mid \boldsymbol{X}_i, A_i = 0]$

```{r define-A_untreated}
A_untreated <- 0 # transport from 1 to 0
```

Let us split the data between treated (Black individuas) and untreated (white individuals).
```{r define-tb_untreated}
tb_untreated <- tb |> filter(!!sym(A_name) == !!A_untreated)
tb_treated <- tb |> filter(!!sym(A_name) != !!A_untreated)

n_untreated <- nrow(tb_untreated)
n_treated <- nrow(tb_treated)
```

We train a random forest to predict recidivism, among the untreated only (white individuals): $\hat{\mu}_0()$.

```{r define-mu_untreated_model}
mu_untreated_model <- randomForest(
  x = tb_untreated |> select(-!!Y_name, -!!A_name),
  y = factor(pull(tb_untreated, !!Y_name), levels = c(0,1))
)
```

The transported values for age, prior counts and charge degrees of all treated (Black individuals): $x_{1,i}^\star$
```{r define-D_treated_t}
tb_treated_t <- sequential_transport$transported |> 
  as_tibble() |>
  unnest_wider(where(is.list))
```

The prediction of the algorithm on those transported individuals, i.e., $\hat{\mu}_0(x_{1,i}^\star)$
```{r define-pred_treated_t}
pred_treated_t <- predict(mu_untreated_model, newdata = tb_treated_t)
```

We can then compute the ATT (@eq-att-cot).

```{r}
# ATT with the counterfactuals
Y_treated_obs <- tb |> filter(!!sym(A_name) != !!A_untreated) |> pull(!!Y_name)
ATT_cot <- mean(Y_treated_obs - ifelse(pred_treated_t == 0, 0, 1))
ATT_cot
```

### ATT with the AIPW Estimator

We use cross-fitting to estimate the average treatment on the treated using the AIPW estimator:
$$
\widehat{\text{ATT}}_{\text{AIPW}} = \frac{1}{n_1} \sum_{i: A_i = 1} \left[ Y_i - \hat{\mu}_0(X_i) \right] + \frac{1}{n_1} \sum_{i: A_i = 0} \frac{\hat{e}(X_i)}{1 - \hat{e}(X_i)} \left[ Y_i - \hat{\mu}_0(X_i) \right]
$$

where $\hat{e}\bigl(\boldsymbol{X}_i\bigr)$ is the estimation of the propensity score $e(X_i) = \mathbb{P}(A_i = 1 \mid \boldsymbol{X}_i)$.

```{r define-e_hat}
set.seed(seed)
n <- n_untreated + n_treated
n_folds <- 5 # 5-fold cross-fitting
folds <- sample(rep(1:n_folds, length.out = n))
# Init results
## outcomes
mu_untreated_hat <- rep(NA, n)
mu_treated_hat <- rep(NA, n)
## propensity scores
e_hat  <- rep(NA, n)

for (k in 1:n_folds) {
  idx_valid <- which(folds == k)
  idx_train <- setdiff(1:n, idx_valid)
  tb_train <- tb |> slice(idx_train)
  tb_valid <- tb |> slice(-idx_train)
  # Outcome models
  mu_untreated_model <- randomForest(
    x = tb_train |> filter(!!sym(A_name) == !!A_untreated) |> 
      select(-!!Y_name, -!!A_name),
    y = tb_train |> filter(!!sym(A_name) == !!A_untreated) |> 
      pull(!!Y_name) |> factor(levels = c(0, 1))
  )
  mu_treated_model <- randomForest(
    x = tb_train |> 
      filter(!!sym(A_name) != !!A_untreated) |> select(-!!Y_name, -!!A_name),
    y = tb_train |> filter(!!sym(A_name) != !!A_untreated) |> 
      pull(!!Y_name) |> factor(levels = c(0, 1))
  )
  
  mu_untreated_hat[idx_valid] <- predict(
    mu_untreated_model, newdata = tb_valid |> select(-!!Y_name, -!!A_name)
  ) |> as.character() |> as.numeric()
  mu_treated_hat[idx_valid] <- predict(
    mu_treated_model, newdata = tb_valid |> select(-!!Y_name, -!!A_name)
  ) |> as.character() |> as.numeric()
  
  # Propensity model
  ps_model <- glm(
    paste(A_name, " ~ ."), data = tb_train |> select(-!!Y_name),
    family = binomial()
  )
  # Propensity scores
  e_hat[idx_valid] <- predict(
    ps_model, newdata = tb_valid, type = "response"
  )
}
```

For convenience, let us extract the treatment and the outcome:
```{r define-treated_idx}
A <- pull(tb, !!A_name)
Y <- pull(tb, !!Y_name)
# Index of treated
treated_idx <- which(A != A_untreated)
```

Lastly, we can compute the ATT with the AIPW estimator:

```{r define-ATT_aipw}
aipw_terms <- A * (Y - mu_untreated_hat) +
  (1 - A) * (e_hat / (1 - e_hat)) * (Y - mu_untreated_hat)
ATT_aipw <- sum(aipw_terms[treated_idx]) / sum(A == 1)
ATT_aipw
```

### ATT with a Causal Forest

Let us apply a causal forest to estimate the ATT.

First, we need to perform 1-hot encoding for categorical variables to comply with the requirements of the `causal_forest()`{R} from {grf}.
```{r define-X_mat}
# 1-hot-encoding
X_mat <- tb |> select(-!!Y_name, -!!A_name)
X_mat <- model.matrix(~ . - 1, data = X_mat)
```

We train the causal forest:
```{r define)fit_cf}
fit_cf <- causal_forest(
  X = X_mat, 
  Y = Y, 
  W = A
)
```


```{r define-ATT_dml}
# the individual treatment effects
tau_hat <- predict(fit_cf)$predictions
# the ATT
ATT_dml <- mean(tau_hat[treated_idx])
ATT_dlm_se <- sqrt(var(tau_hat[treated_idx]) / n_treated)

# This can also be obtained as follows:
# average_treatment_effect(fit_cf, target.sample = "treated")

# The ATT:
ATT_dml
```

### Summary

```{r}
tibble(ATT_cot = ATT_cot, ATT_aipw = ATT_aipw, ATT_dml = ATT_dml)
```

