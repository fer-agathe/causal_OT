# Compas


:::{.callout-note}

## Objectives

In this page, we calculate the average total causal effect, the average natural direct effect and the causal mediation effect (or indirect effect) of COMPAS dataset assuming a known causal graph. We compare three methodologies to estimate those effects:
- Using Optimal Transport (OT) to first derive counterfactuals at the individual level and then, averaging over all the individuals in the dataset,
- Using Sequential Transport (ST) to first derive counterfactuals at the individual level and then, averaging over all the individuals in the dataset,
- Using LSEM from causal mediation analysis that fits linear models to estimate the different average causal effects.

:::

```{r package-settings}
#| warning: false
#| message: false
library(tidyverse)
# remotes::install_github(
#   repo = "fer-agathe/sequential_transport", subdir = "seqtransfairness"
# )
library(seqtransfairness)
# remotes::install_github(repo = "fer-agathe/transport-simplex")
library(transportsimplex)
library(randomForest)
library(grf)
library(cluster)

# Also required:
# install.packages(mlr3fairness)
```

```{r}
#| echo: false
#| eval: true
#| message: false
#| warning: false
#| file: _myfunctions.R
```

$$
\definecolor{wongBlack}{RGB}{0,0,0}
\definecolor{wongGold}{RGB}{230, 159, 0}
\definecolor{wongLightBlue}{RGB}{86, 180, 233}
\definecolor{wongGreen}{RGB}{0, 158, 115}
\definecolor{wongYellow}{RGB}{240, 228, 66}
\definecolor{wongBlue}{RGB}{0, 114, 178}
\definecolor{wongOrange}{RGB}{213, 94, 0}
\definecolor{wongPurple}{RGB}{204, 121, 167}
\definecolor{colA}{RGB}{255, 221, 85}
\definecolor{colB}{RGB}{148, 78, 223}
\definecolor{colC}{RGB}{63, 179, 178}
\definecolor{colGpeZero}{RGB}{127, 23, 14}
\definecolor{colGpeUn}{RGB}{27, 149, 224}
$$

```{r graphs-settings}
#| code-fold: true
#| code-summary: Codes for graphical parameters.
library(extrafont, quietly = TRUE)
font_family <- "CMU Serif"


path <- "./figs/"
if (!dir.exists(path)) dir.create(path)
```

We load the functions that will allow us to build the counterfactuals (see @sec-functions):
```{r source-functions}
source("../scripts/functions.R")
```


## Data

We load the COMPAS dataset that is available in the {mlr3fairness} package.

```{r load-compas-data}
data(compas, package = "mlr3fairness")
```

The outcome variable is binary here: whether the defendant is rearrested at any time. The "treatment" $A$ will be the sensitive attribute, `race`. We will consider a binary version of the race: `Caucasian` (whites, $A=1$) and `African-American` (Blacks, $A=0$). The idea is to build counterfactuals for Black people to ask questions such as "had this Black individual been white, what whould the prediction of an algorithm modeling recidivism be?".

To train the predictive model of recidivism, we will use the following covariates: the age, the prior criminal records of defendants, and the charge degree (felony or misdemeanor).

```{r define-tb}
tb <- compas |> 
  as_tibble() |> 
  filter(race %in% c("Caucasian", "African-American")) |>
  select(
    race, # sensitive
    age, 
    priors_count, # The prior criminal records of defendants. 
    c_charge_degree, # F: Felony M: Misdemeanor
    is_recid # outcome
  ) |> 
  mutate(
   race = ifelse(race == "African-American", 0, 1), # African-American as "untreated"
   is_recid = ifelse(is_recid == 0, 0, 1)
  )
  # working with a fraction of observations here (40%)
```

```{r show-summary-tb}
dim(tb)
summary(tb)
```

We assume the DAG shown in @fig-dag-compas.

```{r}
#| fig-cap: Assumed structural model for the probability of recidivism.
#| label: fig-dag-compas
variables <- c("race", 
               "age", "priors_count", "c_charge_degree", 
               "is_recid")
# Row: outgoing arrow
adj <- matrix(
  # S  1  2  3  Y
  c(0, 1, 1, 1, 1,# S
    0, 0, 1, 2, 1,# 1 (age)
    0, 0, 0, 0, 1,# 2 (priors_count)
    0, 0, 0, 0, 1,# 3 (c_charge_degree)
    0, 0, 0, 0, 0 # Y
  ),
  ncol = length(variables),
  dimnames = rep(list(variables), 2),
  byrow = TRUE
)

causal_graph <- fairadapt::graphModel(adj)
plot(causal_graph)
```

## Counterfactuals

Let us set a seed for reproducibility.

```{r}
seed <- 1234
set.seed(seed)
```

```{r}
A_name <- "race" # treatment name
Y_name <- "is_recid" # outcome name
A_untreated <- 0
A <- tb[[A_name]]
ind_untreated <- which(A == A_untreated)
tb_untreated <- tb[ind_untreated, ]
tb_treated <- tb[-ind_untreated, ]
```

Let us follow the DAG from @fig-dag-compas and build the counterfactuals of Black individuals: we thus transport individuals from $A=0$ to $A=1$, using the predictions on the test set. 

### Multivariate Optimal Transport

We apply multivariate optimal transport (OT), following the methodology developed in @de2024transport.

```{r}
tb_untreated_wo_A <- tb_untreated[ , !(names(tb_untreated) %in% A_name)]
tb_treated_wo_A <- tb_treated[ , !(names(tb_treated) %in% A_name)]
n0 <- nrow(tb_untreated_wo_A)
n1 <- nrow(tb_treated_wo_A)
y0 <- tb_untreated_wo_A[[Y_name]]
y1 <- tb_treated_wo_A[[Y_name]]
X0 <- tb_untreated_wo_A[ , !(names(tb_untreated_wo_A) %in% Y_name)]
X1 <- tb_treated_wo_A[ , !(names(tb_treated_wo_A) %in% Y_name)]
```

To apply Optimal Transport on the COMPAS dataset, we first need to one-hot the categorical variables.

```{r}
num_cols <- names(X0)[sapply(X0, is.numeric)]
cat_cols <- names(X0)[sapply(X0, function(col) is.factor(col) || is.character(col))]
X0_num <- X0[ , num_cols]
X1_num <- X1[ , num_cols]
X0_cat <- X0[ , cat_cols]
X1_cat <- X1[ , cat_cols]

cat_counts <- sapply(X0[ , cat_cols], function(col) length(unique(col)))
```

Categorical variables are one-hot encoded:
```{r}
library(caret)
X0_cat_encoded <- list()
X1_cat_encoded <- list()
for (col in cat_cols) {
  # One-hot encoding with dummyVars
  formula <- as.formula(paste("~", col))
  dummies <- dummyVars(formula, data = X0_cat)
  
  # Dummy variable
  dummy_0 <- predict(dummies, newdata = X0_cat) %>% as.data.frame()
  dummy_1 <- predict(dummies, newdata = X1_cat) %>% as.data.frame()
  
  # Scaling
  dummy_0_scaled <- scale(dummy_0)
  dummy_1_scaled <- scale(dummy_1)

  dummy_0_df <- as.data.frame(dummy_0_scaled)
  dummy_1_df <- as.data.frame(dummy_1_scaled)
  
  # Aling categories in both treated/untreated groups
  all_cols <- union(colnames(dummy_0_df), colnames(dummy_1_df))
  dummy_0_df <- dummy_0_df %>% mutate(across(.fns = identity)) %>% select(all_of(all_cols)) %>% replace(is.na(.), 0)
  dummy_1_df <- dummy_1_df %>% mutate(across(.fns = identity)) %>% select(all_of(all_cols)) %>% replace(is.na(.), 0)
  
  # Sauvegarde dans les listes
  X0_cat_encoded[[col]] <- dummy_0_df
  X1_cat_encoded[[col]] <- dummy_1_df
}
```
We calculate Euclidean distance for numerical variables.

```{r}
# library(proxy)
num_dist <- proxy::dist(x = X0_num, y = X1_num, method = "Euclidean")
num_dist <- as.matrix(num_dist)
```

For categorical variables, we use the Hamming distance.
```{r}
cat_dists <- list()
for (col in cat_cols) {
  mat_0 <- as.matrix(X0_cat_encoded[[col]])
  mat_1 <- as.matrix(X1_cat_encoded[[col]])
  dist_mat <- proxy::dist(x = mat_0, y = mat_1, method = "Euclidean")
  cat_dists[[col]] <- as.matrix(dist_mat)
}
```

Then we need to combine the two distance matrices. We use weights equal to the proportion of numerical variables and the proportion of categorical variables, respectively for distances based on numerical and categorical variables.

```{r}
combined_cost <- num_dist
for (i in seq_along(cat_dists)) {
  combined_cost <- combined_cost + cat_dists[[i]]
}
```

Then, we can compute the transport map:
```{r}
# Uniform weights (equal mass)
w0 <- rep(1 / n0, n0)
w1 <- rep(1 / n1, n1)
# Compute transport plan
transport_res <- transport::transport(
  a = w0,
  b = w1,
  costm = combined_cost,
  method = "shortsimplex"
)

transport_plan <- matrix(0, nrow = n0, ncol = n1)
for(i in seq_len(nrow(transport_res))) {
  transport_plan[transport_res$from[i], transport_res$to[i]] <- transport_res$mass[i]
}
```

We first transport the numerical variables.
```{r}
num_transported <- n0 * (transport_plan %*% as.matrix(X1_num))
```

Then, we transport the categorical variables with label reconstruction (not perfect here).
```{r}
cat_transported <- list()
for (col in cat_cols) {
  cat_probs <- transport_plan %*% as.matrix(X1_cat_encoded[[col]])
  cat_encoded_columns <- colnames(X1_cat_encoded[[col]])
  # For each obs., we take the index with the maximum value (approx. proba)
  max_indices <- apply(cat_probs, 1, which.max)
  prefix_pattern <- paste0("^", col, "\\.")
  cat_transported[[col]] <- sapply(max_indices, function(x) sub(prefix_pattern, "", cat_encoded_columns[x]))
}
```

We can now store the results into a tibble.
```{r}
tb_ot_transported <- as_tibble(num_transported)
for (col in cat_cols) {
  tb_ot_transported[[col]] <- cat_transported[[col]]
}

save(tb_ot_transported, file = "../output/ot-compas.rda")
```

```{r}
# Load tb_ot_transported
load("../output/ot-compas.rda")
tb_ot_transported <- tb_ot_transported |>
  mutate(c_charge_degree = as.factor(c_charge_degree))
tb_ot_transported <- as.list(tb_ot_transported)
```

### Sequential Transport

We call the  `seq_trans()`{.R} function (see [Chapter -@sec-functions]) function to build the counterfactuals of Black individuals. The estimations are done using parallel computation.

```{r define-sequential_transport}
library(pbapply)
library(parallel)
ncl <- detectCores()-1
(cl <- makeCluster(ncl))

clusterEvalQ(cl, {
  library(transportsimplex)
}) |>
  invisible()


A_name <- "race" # treatment name
Y_name <- "is_recid" # outcome name

sequential_transport <- seq_trans(
  data = tb, 
  adj = adj, 
  s = A_name, 
  S_0 = 0, # source: untreated
  y = Y_name, 
  num_neighbors = 50, 
  num_neighbors_q = NULL,
  silent = FALSE,
  cl = cl
)

save(sequential_transport, file = "../output/seq-t-compas.rda")

stopCluster(cl)
```
```{r}
# Load sequential_transport
load("../output/seq-t-compas.rda")
```

## Measuring the Causal Effect

### With Causal Mediation Analysis

Let us use the `multimed()`{.R} function from {mediation} to estimate the direct effect:
- race -> is_recid (ir),
and the different indirect effects:
- race -> age -> is_recid,
- race -> priors_count (pc) -> is_recid,
- race -> c_charge_degree (ccd) -> is_recid,
- race -> age -> priors_count -> is_recid,
- race -> age -> c_charge_degree -> is_recid.

```{r estim-causal-effect-mediation}
#| message: false
#| warning: false
# library(mediation) # we do not load it
#  otherwise it masks a lot of useful functions

# We encode the categorical variable as for optimal transport
tb_med <- tb |> 
  mutate(
    c_charge_degree = ifelse(c_charge_degree == "F", 0, 1)
  )

med_mod_age <- mediation::multimed(
  outcome = "is_recid", 
  med.main = "age", 
  med.alt = c("priors_count", "c_charge_degree"), 
  treat = "race", 
  data = tb_med
)
# Indirect effect for age: race -> age -> ir
delta_0_med_age <- mean((med_mod_age$d0.lb + med_mod_age$d0.ub) / 2)
# Direct + Other indirect effects: race -> ir, race -> pc -> ir, race -> ccd -> ir, 
# race -> age -> pc -> ir, race -> age -> ccd -> ir
zeta_1_med_age <- mean((med_mod_age$z1.lb + med_mod_age$z1.ub) / 2)
# Total effect
tot_effect_med_age <- delta_0_med_age + zeta_1_med_age

med_mod_pc <- mediation::multimed(
  outcome = "is_recid", 
  med.main = "priors_count", 
  med.alt = c("age", "c_charge_degree"), 
  treat = "race", 
  data = tb_med
)
# Indirect effect for pc: race -> pc -> ir, race -> age -> pc -> ir
delta_0_med_pc <- mean((med_mod_pc$d0.lb + med_mod_pc$d0.ub) / 2)
# Direct + Other indirect effects: race -> ir, race -> age -> ir, race -> ccd -> ir, 
# race -> age -> ccd -> ir
zeta_1_med_pc <- mean((med_mod_pc$z1.lb + med_mod_pc$z1.ub) / 2)
# Total effect
tot_effect_med_pc <- delta_0_med_pc + zeta_1_med_pc

med_mod_ccd <- mediation::multimed(
  outcome = "is_recid", 
  med.main = "c_charge_degree", 
  med.alt = c("age", "priors_count"), 
  treat = "race", 
  data = tb_med
)
# Indirect effect for ccd: race -> ccd -> ir, race -> age -> ccd -> ir
delta_0_med_ccd <- mean((med_mod_ccd$d0.lb + med_mod_ccd$d0.ub) / 2)
# Direct + Other indirect effects: race -> ir, race -> age -> ir, race -> pc -> ir, 
# race -> age -> pc -> ir
zeta_1_med_ccd <- mean((med_mod_ccd$z1.lb + med_mod_ccd$z1.ub) / 2)
# Total effect
tot_effect_med_ccd <- delta_0_med_ccd + zeta_1_med_ccd
```

The estimated values:

```{r show-estim-mediation}
# Total effect
tot_effect_med <- tot_effect_med_age
# Indirect effects
delta_0_med <- delta_0_med_age + delta_0_med_pc + delta_0_med_ccd
# Direct effect 
zeta_1_med <- tot_effect_med - delta_0_med
cbind(delta_0 = delta_0_med, zeta_1 = zeta_1_med, tot_effect = tot_effect_med)
```

### With Optimal Transport

```{r library-randomForest}
#| message: false
#| warning: false
library(randomForest)
```

We use a random forest to estimate the outcome model (see `causal_effects_cf()`{.R} in [Chapter -@sec-functions]).

```{r}
#| warning: false
#| message: false

causal_effects_ot <- causal_effects_cf(
  data_untreated = tb_untreated, 
  data_treated = tb_treated,
  data_cf = as_tibble(tb_ot_transported), 
  Y_name = Y_name, 
  A_name = A_name, 
  A_untreated = A_untreated # 0
)

cbind(
  delta_0 = causal_effects_ot$delta_0,
  zeta_1 = causal_effects_ot$zeta_1, 
  tot_effect = causal_effects_ot$tot_effect
)
```

### With Sequential Transport

```{r}
#| warning: false
#| message: false

causal_effects_st <- causal_effects_cf(
  data_untreated = tb_untreated, 
  data_treated = tb_treated,
  data_cf = as_tibble(sequential_transport$transported), 
  Y_name = Y_name, 
  A_name = A_name, 
  A_untreated = A_untreated
)

cbind(
  delta_0 = causal_effects_st$delta_0,
  zeta_1 = causal_effects_st$zeta_1, 
  tot_effect = causal_effects_st$tot_effect
)
```
