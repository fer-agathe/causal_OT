# Transporting a Categorical Variable


:::{.callout-note}

## Objectives

In this notebook, we illustrate how to perform random matching and matching based on optimal transport for individuals described with a categorical variable (using the distances between the probabilities of being in each category). We use a toy example to make it as simple as possible.


:::

```{r package-settings}
#| warning: false
#| message: false
library(tidyverse)

```

```{r}
#| echo: false
#| eval: true
#| message: false
#| warning: false
#| file: _myfunctions.R
```

$$
\definecolor{wongBlack}{RGB}{0,0,0}
\definecolor{wongGold}{RGB}{230, 159, 0}
\definecolor{wongLightBlue}{RGB}{86, 180, 233}
\definecolor{wongGreen}{RGB}{0, 158, 115}
\definecolor{wongYellow}{RGB}{240, 228, 66}
\definecolor{wongBlue}{RGB}{0, 114, 178}
\definecolor{wongOrange}{RGB}{213, 94, 0}
\definecolor{wongPurple}{RGB}{204, 121, 167}
\definecolor{colA}{RGB}{255, 221, 85}
\definecolor{colB}{RGB}{148, 78, 223}
\definecolor{colC}{RGB}{63, 179, 178}
\definecolor{colGpeZero}{RGB}{127, 23, 14}
\definecolor{colGpeUn}{RGB}{27, 149, 224}
$$

```{r graphs-settings}
#| code-fold: true
#| code-summary: Codes for graphical parameters.
library(extrafont, quietly = TRUE)
loadfonts(device = "pdf", quiet = TRUE)
col_categ <- c("A" = "#ffdd55", "B" = "#944edf", "C" = "#3fb3b2")
font_size <- 20
font_family <- "CMU Serif"

path <- "./figs/"
if (!dir.exists(path)) dir.create(path)

theme_paper <- function(...) {
  font_family <- "CMU Serif"
  font_size <- 20
  theme(
    text = element_text(family = font_family, size = unit(font_size, "pt")),
    plot.background = element_rect(fill = "transparent", color = NA),
    legend.text = element_text(size = rel(1.1)),
    legend.title = element_text(size = rel(1.1)),
    legend.key = element_blank(),
    panel.spacing = unit(1, "lines"),
    plot.title = element_text(hjust = 0, size = rel(1.3), face = "bold"),
    plot.title.position = "plot",
    strip.background = element_rect(fill = NA, colour = NA),
    strip.text = element_text(size = rel(1.1))
  )
}

theme_ggtern <- function(...) {
  font_family <- "CMU Serif"
  font_size <- 20
  theme(
    strip.background = element_rect(colour = "black", fill = NA),
    strip.text.x = element_text(colour = "black"),
    strip.text = ggtext::element_markdown(),
    text = element_text(family = font_family, size = unit(font_size, "pt")),
    axis.title = element_text(size = rel(1)),
    tern.axis.arrow.show = TRUE,
    tern.axis.arrow.sep = .13,
    tern.axis.vshift = .05,
    panel.border = element_rect(colour = NA)
  )
}
```
## Setup

As in the previous pages, assume two groups: 0 and 1. In the first group, there are $n_0=6$ individuals indexed 1, 2, 3, 4, 5, 6; and in group 1, there are $n_1=6$ individuals indexed 7, 8, 9, 10, 11, 12. Let $Y$ denote a response variable that takes values in $\mathbb{R}$, and let $X$ be a categorical variable taking values $\{A,B,C\}$.

Let us assume that we obtained the estimated probabilities of being in each class using a multinomial regression model. This allows to convert categorical observations $\{x_{1,1},\cdots,x_{1,n_1}\}$ and $\{x_{0,1},\cdots,x_{0,n_0}\}$
into estimated probabilities, $\{\boldsymbol{p}_{1,1},\cdots,\boldsymbol{p}_{1,n_1}\}$ and $\{\boldsymbol{p}_{0,1},\cdots,\boldsymbol{p}_{0,n_0}\}$.


Let us create a toy example:

```{r definition-obs}
group_0 <- tribble(
  ~i, ~x, ~p_A, ~p_B, ~p_C, ~y,
  1, "A", .8,   .1,   .1,   1,
  2, "A", .7,   .2,   .1,   2,
  3, "A", .6,   .1,   .3,   3,
  4, "B", .2,   .7,   .1,   4,
  5, "B", .3,   .6,   .1,   5,
  6, "C", .1,   .2,   .7,   6
)

group_1 <- tribble(
  ~i, ~x, ~p_A, ~p_B, ~p_C, ~y,
  7,  "A", .7,  .2,   .1,   3,
  8,  "B", .1,  .7,   .2,   4,
  9,  "B", .6,  .2,   .2,   5,
  10, "B", .2,  .5,   .3,   6,
  11, "C", .3,  .1,   .6,   7,
  12, "C", .1,  .3,   .6,   8
)
```

## Random Matching

There are $6!=720$ different random matching that can be done. We will show two of them below.

### First Random Matching

Let us first consider a random matching in which the individuals matched are 1 (group 0) and 12 (group 1), 2 and 9, 3 and 7, 4 and 10, 5 and 8, 6 and 12. We can compute the difference $y(1) - y(0)$ for each pair of matched individuals (column diff in the table below).

```{r define-matched_ex_1}
matched_ex_1 <- tribble(
  ~i_0, ~i_1,
  1, 12,
  2, 9,
  3, 7,
  4, 10,
  5, 8,
  6, 11
) |>
  left_join(
    group_0 |>
      rename_with(~str_c(.x, "_0")),
    by = "i_0"
  ) |>
  left_join(
    group_1 |>
      rename_with(~str_c(.x, "_1")),
    by = "i_1"
  )

tb_att_1 <- 
  matched_ex_1 |>
  mutate(diff = y_1 - y_0) |>
  select(i_0, i_1, diff, x_0, x_1)
tb_att_1
```
The average treatment on the treated is thus, in that case:
```{r show-att-example1}
mean(tb_att_1$diff)
```

And if we compute the ATT by category of $X$:
```{r show-att-example1-categ}
tb_att_1 |> group_by(x_1) |> summarise(ATT = mean(diff))
```




### Second Random Matching

We can consider, for the sake of illustration, a second random matching, where the individuals matched are 1 and 8, 2 and 7, 3 and 11, 4 and 10, 5 and 9, 6 and 12. Again, we can compute the difference in outcomes $y(1)-y(0)$ for each pair of matched individuals.

```{r define-matched_ex_2}
matched_ex_2 <- tribble(
  ~i_0, ~i_1,
  1, 8,
  2, 7,
  3, 11,
  4, 10,
  5, 9,
  6, 12
) |>
  left_join(
    group_0 |>
      rename_with(~str_c(.x, "_0")),
    by = "i_0"
  ) |>
  left_join(
    group_1 |>
      rename_with(~str_c(.x, "_1")),
    by = "i_1"
  )

tb_att_2 <- matched_ex_2 |>
  mutate(diff = y_1 - y_0) |>
  select(i_0, i_1, diff, x_0, x_1)
tb_att_2
```

The average treatment on the treated is thus, in that case:
```{r show-att-example2}
mean(tb_att_2$diff)
```

And if we compute the ATT by category of $X$:
```{r show-att-example2-groups}
tb_att_2 |> group_by(x_1) |> summarise(ATT = mean(diff))
```


## Matching Based on Euclidean Distances

Let us now perform optimal matching, based on the distances between the individuals from the two groups. We use the Euclidean distance between the centered log ratio (clr) transform of the probabilities of being in the three classes.

Let us first extract the probabilities only and compute the clr transform of the compositional data.
```{r define-all_coords}
#| message: false
#| warning: false
library(compositions)
all_coords <- rbind(
  as.matrix(group_0[, c("p_A", "p_B", "p_C")]),
  as.matrix(group_1[, c("p_A", "p_B", "p_C")])
) |> 
  clr()
```

Then, we can compute the Euclidean distances between each individual and focus on the distances between individuals from one group to the other.
```{r}
row.names(all_coords) <- c(group_0$i, group_1$i)
# Euclidean distances between the clr transform of the propensities
D <- as.matrix(dist(all_coords, method = "euclidean"))
n0 <- nrow(group_0)
n1 <- nrow(group_1)
between_distances <- D[(n0 + 1):(n0 + n1), 1:n0]
round(between_distances, 2)
```
We can then use these distances as the costs to find an optimal mapping from group 1 to group 0. In a nutshell, we want to find an optimal matching between  $\{\boldsymbol{p}_{1,1},\cdots,\boldsymbol{p}_{1,n_1}\}$ and $\{\boldsymbol{p}_{0,1},\cdots,\boldsymbol{p}_{0,n_0}\}$. The probabilities are associated, respectively, with weights $\boldsymbol{w}_1=(w_{11},\cdots,w_{1n_1})$, and $\boldsymbol{w}_0=(w_{01},\cdots,w_{0n_0})$. 

To do so, we need to solve the following linear system:
$$
\min_{P\in\mathcal{U}(\boldsymbol{1}_{n_1},\boldsymbol{1}_{n_0})}
\langle P,\,C\rangle,\text{ where }\langle P,\,C\rangle
=\sum_{i=1}^{n_1}\sum_{j=1}^{n_0}P_{ij}\,C_{ij},
$$
where $\mathcal{U}(\boldsymbol{w}_1,\boldsymbol{w}_0)$ is defined as
$$
\bigl\{\,P\in\mathbb{R}_+^{n_1\times n_0}:
P\,\mathbf{1}_{n_0}=\boldsymbol{w}_1,\ 
P^\top\mathbf{1}_{n_1}=\boldsymbol{w}_0
\bigr\},
$$
and where 
$$
C:=[C_{i,j}]\text{ where }C_{i,j}=c(\boldsymbol{p}_{1,i},\boldsymbol{p}_{0,j})
$$
is the "Dirichlet transport" (@baxendale2022random) and where the cost function is the cross-entropy:
based on the cross-entropy,
$$
\begin{equation*}
 c(\mathbf{x},\mathbf{y})=\log\left(\frac{1}{d}\sum_{i=1}^d\frac{y_i}{x_i}\right)-\frac{1}{d}\sum_{i=1}^d\log\left(\frac{y_i}{x_i}\right),
\end{equation*}
$$

Here, we consider that $\mathcal{U}(\boldsymbol{1}_{n_1},\boldsymbol{1}_{n_0})$ is the polytope
$$
\left\{\,P\in\mathbb{R}_+^{n_1\times n_0}:
P\,\mathbf{1}_{n_0}=\frac{\mathbf{1}_{n_1}}{n_1},\ 
P^\top\mathbf{1}_{n_1}=\frac{\mathbf{1}_{n_0}}{n_0}
\right\}.
$$


```{r define-ot_plan}
# source weights
mass_source <- rep(1 / n1, n1)
# target weights
mass_target <- rep(1 / n0, n0)

# Solve the optimal transport plan
ot_plan <- transport::transport(
  a = mass_source, b = mass_target, costm = between_distances, 
  method = "networkflow"
)
ot_plan$i_0 <- group_0$i[ot_plan$to]
ot_plan$i_1 <- group_1$i[ot_plan$from]
ot_plan
```

We can visualize the results in a ternary plot (@fig-ternary-toy). The lines depict the matched individuals (shown by dots and their index).


```{r}
#| code-fold: true
#| code-summary: Codes to create the Figure.
#| fig-cap: 1-to-1 Matching with optimal transport based on the distances between the individuals with respect to their estimated probabilities of being in each class.
#| label: fig-ternary-toy
#| message: false
#| warning: false
all_data <- 
  bind_rows(group_0 |> mutate(group = "0"), group_1 |> mutate(group = "1"))

library(ggtern)

p <- ggtern(
  data = all_data |> 
    left_join(
      ot_plan |> 
        mutate(
          i_0 = as.numeric(i_0),
          i_1 = as.numeric(i_1),
          id_match = as.character(row_number())
        ) |> 
        dplyr::select(i_0, i_1, id_match) |> 
        pivot_longer(cols = c(i_0, i_1), values_to = "i") |> 
        dplyr::select(-name)
    ),
  mapping = aes(x = p_A, y = p_B, z = p_C, group = id_match)
) +
  geom_point(mapping = aes(shape = group, colour = x), size = 4) +
  geom_text(
    mapping = aes(
      label = i, 
      x = p_A + ifelse(group == 0, -1, 1) * 0.05
    ),
    size = .3*font_size
  ) +
  labs(x = "$p_A$", y = "$p_B$", z = "$p_C") +
  geom_line(
    colour = "gray40", 
    # mapping = aes(linetype = id_match)
  ) +
  scale_colour_manual(name = "category", values = col_categ) +
  scale_shape_discrete(name = "group") +
  theme_light(base_size = font_size, base_family = font_family) +
  # theme_paper() +
  theme_ggtern() +
  theme(
    legend.title = element_text(size = .8*font_size),
    legend.text = element_text(size = .8*font_size)
  ) +
  theme_latex(TRUE) +
  theme_hidetitles()

p
```

```{r export-ternary-toy-pdf}
#| code-fold: true
#| code-summary: Codes to export the figure in PDF.
filename <- "ternary-toy"
ggsave(
  p, file = str_c(path, filename, ".pdf"),
  height = 2.2*1.75, width = 4*1.75,
  family = font_family,
  device = cairo_pdf
)
# Crop PDF
system(paste0("pdfcrop ", path, filename, ".pdf ", path, filename, ".pdf"))
```

We can compute the differences $y(1)-y(0)$ for each matched individuals.

```{r define-ot_plan_diff}
ot_plan_diff <- 
  ot_plan |> 
  left_join(group_0 |> select(i_0 = i, y_0 = y, x_0 = x), by = "i_0") |> 
  left_join(group_1 |> select(i_1 = i, y_1 = y, x_1 = x), by = "i_1") |> 
  mutate(diff = y_1 - y_0) |>
  select(i_0, i_1, diff, x_0, x_1)
ot_plan_diff
```

Resulting in an ATT of:
```{r show-att-ot}
mean(ot_plan_diff$diff)
```

And if we compute the ATT by category of $X$:
```{r show-att-ot-groups}
ot_plan_diff |> group_by(x_1) |> summarise(ATT = mean(diff))
```

